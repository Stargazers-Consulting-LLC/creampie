#!/usr/bin/env python3
"""JSON Output Helper for AI Tooling.

This module provides a helper class for generating proper JSON output for AI tooling.
All helper scripts should use this class to ensure consistent, AI-friendly output.

References:
    - [Python Style Guide](humans/guides/python_style_guide.md)
    - [AI Documentation Rules](ai/ai_rules.json)

### Legal
SPDX-FileCopyright Â© Robert Ferguson <rmferguson@pm.me>

SPDX-License-Identifier: [MIT](https://spdx.org/licenses/MIT.html)
"""

# Standard library imports
import json
import os
from datetime import datetime
from typing import Any, TypedDict

# Local imports
# (None for this module)

# Module-level constants
DEFAULT_SUCCESS = True

# Module-level variables
# (None for this module)


class ResultsDict(TypedDict):
    success: bool
    data: dict[str, Any]
    errors: list[str]
    warnings: list[str]


class OutputHelper:
    """Helper class for generating proper JSON output for AI tooling.

    This class provides standardized methods for creating AI-friendly JSON output
    that includes proper metadata, structured results, and both human-readable
    and machine-readable formats.
    """

    def __init__(self, script_name: str, output_category: str) -> None:
        """Initialize the AI output helper.

        Args:
            script_name: Name of the script generating output.
            output_category: Category for organizing output files.
        """
        self.script_name = script_name
        self.output_category = output_category
        self.project_root = "."
        self.ai_outputs_dir = os.path.join(self.project_root, "ai", "outputs", output_category)
        self.results: ResultsDict = {"success": DEFAULT_SUCCESS, "data": {}, "errors": [], "warnings": []}

    def add_result(self, key: str, value: Any) -> None:
        """Add a result to the output data.

        Args:
            key: The key for the result data.
            value: The value to store.
        """
        self.results["data"][key] = value

    def add_error(self, error: str) -> None:
        """Add an error to the results.

        Args:
            error: The error message to add.
        """
        self.results["errors"].append(error)
        self.results["success"] = False

    def add_warning(self, warning: str) -> None:
        """Add a warning to the results.

        Args:
            warning: The warning message to add.
        """
        self.results["warnings"].append(warning)

    def generate_json_output(self) -> dict[str, Any]:
        """Generate the complete JSON output structure.

        Returns:
            The complete JSON output dictionary with proper metadata.
        """
        return {
            "ai_metadata": {
                "template_version": "4.0",
                "ai_processing_level": "High",
                "required_context": f"Results from {self.script_name}",
                "validation_required": True,
                "code_generation": "Not applicable",
                "cross_references": [f"scripts/{self.script_name}"],
                "maintenance": f"Auto-generated by {self.script_name}",
            },
            "file_info": {
                "purpose": f"Results and status report from {self.script_name}",
                "last_updated": datetime.now().strftime("%Y-%m-%d"),
                "format": "json",
                "optimization_target": "ai_tool_consumption",
                "script_name": self.script_name,
                "output_category": self.output_category,
            },
            "content": {
                "summary": {
                    "success": self.results["success"],
                    "errors_count": len(self.results["errors"]),
                    "warnings_count": len(self.results["warnings"]),
                    "data_keys": list(self.results["data"].keys()),
                    "timestamp": datetime.now().isoformat(),
                },
                "results": self.results["data"],
                "errors": self.results["errors"],
                "warnings": self.results["warnings"],
            },
        }

    def save_output(self, filename: str) -> str:
        """Save the JSON output to the appropriate directory.

        Args:
            filename: Base filename for the output files.

        Returns:
            Path to the saved JSON file.
        """
        # Ensure output directory exists
        os.makedirs(self.ai_outputs_dir, exist_ok=True)

        # Generate JSON output
        json_output = self.generate_json_output()

        # Save JSON file
        json_file = os.path.join(self.ai_outputs_dir, f"{filename}.json")
        with open(json_file, "w", encoding="utf-8") as f:
            json.dump(json_output, f, indent=2)

        # Generate human-readable report
        report_file = os.path.join(self.ai_outputs_dir, f"{filename}.md")
        report = self._generate_human_report(json_output)
        with open(report_file, "w", encoding="utf-8") as f:
            f.write(report)

        return json_file

    def _generate_human_report(self, json_output: dict[str, Any]) -> str:
        """Generate a human-readable markdown report.

        Args:
            json_output: The JSON output to convert to markdown.

        Returns:
            The formatted markdown report string.
        """
        content = json_output["content"]
        summary = content["summary"]

        report = f"""# {self.script_name} Report

**Date:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
**Status:** {"âœ… Success" if summary["success"] else "âŒ Failed"}

## Summary

- **Success:** {summary["success"]}
- **Errors:** {summary["errors_count"]}
- **Warnings:** {summary["warnings_count"]}
- **Data Keys:** {", ".join(summary["data_keys"]) if summary["data_keys"] else "None"}

"""

        if content["results"]:
            report += "\n## Results\n\n"
            for key, value in content["results"].items():
                report += f"### {key}\n\n```json\n{json.dumps(value, indent=2)}\n```\n\n"

        if content["errors"]:
            report += "\n## âŒ Errors\n\n"
            for error in content["errors"]:
                report += f"- {error}\n"

        if content["warnings"]:
            report += "\n## âš ï¸ Warnings\n\n"
            for warning in content["warnings"]:
                report += f"- {warning}\n"

        return report

    def print_summary(self) -> None:
        """Print a summary to the terminal."""
        summary = self.results
        print(f"\nðŸ“Š {self.script_name} Summary:")
        print(f"âœ… Success: {summary['success']}")
        print(f"âŒ Errors: {len(summary['errors'])}")
        print(f"âš ï¸ Warnings: {len(summary['warnings'])}")
        print(f"ðŸ“„ Data keys: {list(summary['data'].keys())}")

        if summary["errors"]:
            print("\nâŒ Errors:")
            for error in summary["errors"]:
                print(f"  - {error}")

        if summary["warnings"]:
            print("\nâš ï¸ Warnings:")
            for warning in summary["warnings"]:
                print(f"  - {warning}")


def example_usage() -> None:
    """Example of how to use the JSON output helper."""
    # Create helper instance
    helper = OutputHelper("example_script", "example_category")

    # Add some example data
    helper.add_result("processed_files", 5)
    helper.add_result("execution_time", "2.3s")
    helper.add_result("config", {"setting1": "value1", "setting2": "value2"})

    # Add some example warnings/errors
    helper.add_warning("File 'test.txt' not found, using default")
    helper.add_error("Failed to process 'corrupt.json'")

    # Save output
    json_file = helper.save_output("example_results")

    # Print summary
    helper.print_summary()

    print(f"\nðŸ“„ JSON output saved to: {json_file}")
    # Convert .json to .md for the report file
    report_file = os.path.splitext(json_file)[0] + ".md"
    print(f"ðŸ“„ Markdown report saved to: {report_file}")


if __name__ == "__main__":
    example_usage()
