{
  "ai_metadata": {
    "purpose": "",
    "last_updated": "",
    "template_version": "2.1",
    "ai_tool_compatibility": "",
    "ai_processing_level": "High",
    "required_context": "Code review processes, style guides, conflict resolution, user interaction patterns",
    "validation_required": "Yes",
    "code_generation": "Supported",
    "cross_references": [
      "Core%20Principles.json",
      "../project_context/Common%20Patterns.json",
      "Language-Specific/Python%20Style%20Guide.json"
    ],
    "maintenance": ""
  },
  "file_info": {
    "file_path": "guide_docs/Code Review Patterns.md",
    "original_format": "markdown",
    "converted_at": "2025-06-18T19:14:30.247986",
    "file_size": 11725,
    "line_count": 265,
    "optimized_at": "2025-06-18T19:19:47.739659",
    "optimization_version": "1.0"
  },
  "content": {
    "sections": [
      {
        "level": 1,
        "title": "Code Review Patterns",
        "content": "> This guide provides comprehensive patterns and best practices for conducting effective code reviews. Use these patterns to ensure code quality, consistency, and maintainability.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "AI Metadata",
        "content": "**Template Version:** 2.1\n**AI Processing Level:** High\n**Required Context:** Code review processes, style guides, conflict resolution, user interaction patterns\n**Validation Required:** Yes\n**Code Generation:** Supported\n**Search Optimization:** Enhanced\n\n**Dependencies:**\n- `Core%20Principles.json.replace(\".json\", \".json\")` - Decision-making frameworks\n- `../project_context/Common%20Patterns.json.replace(\".json\", \".json\")` - Project-specific patterns\n- `Language-Specific/Python%20Style%20Guide.json.replace(\".json\", \".json\")` - Python coding standards\n- `Domain-Specific/` - Domain-specific patterns and guidelines\n\n**Validation Rules:**\n- All suggestions must follow the standard format\n- Priority system must be consistently applied\n- Context awareness must be maintained throughout\n- Communication patterns must be constructive and educational\n- Conflict resolution must follow established frameworks\n\n**Keywords:** code review, suggestions, conflict resolution, communication patterns, priority system, context awareness",
        "subsections": []
      },
      {
        "level": 2,
        "title": "1. Suggestion Structure",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Standard Suggestion Format",
        "content": "```\n**Issue**: [Clear description of the problem]\n**Impact**: [Why this matters - performance, security, maintainability, etc.]\n**Solution**: [Specific, actionable fix]\n**Reasoning**: [Why this approach is preferred]\n```",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Example Suggestion",
        "content": "```\n**Issue**: Magic number `5.0` used in performance assertion\n**Impact**: Reduces code readability and makes maintenance harder\n**Solution**: Define `MAX_PROCESSING_TIME_SECONDS = 5.0` at module level\n**Reasoning**: Follows Python Style Guide principle of avoiding magic numbers\n```",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Multi-Issue Reviews",
        "content": "When multiple issues exist, structure them by priority:\n\n```",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Critical Issues",
        "content": "[Critical issues first]",
        "subsections": []
      },
      {
        "level": 2,
        "title": "High Priority Issues",
        "content": "[Style guide violations, performance issues]",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Medium Priority Issues",
        "content": "[Code organization, documentation]",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Suggestions for Future",
        "content": "[Optional improvements]\n```",
        "subsections": []
      },
      {
        "level": 2,
        "title": "2. Conflict Resolution",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "When Guides Conflict",
        "content": "1. **Identify the conflict**: Clearly state what the guides say differently\n2. **Assess context**: Consider the specific situation and user's needs\n3. **Recommend approach**: Suggest which guide to follow and why\n4. **Explain trade-offs**: Help user understand the implications",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Priority-Based Resolution",
        "content": "1. **Security/Data Integrity**: Always follow strictest guidance\n2. **Project Consistency**: Follow established project patterns\n3. **Performance**: Use performance-focused guidance when relevant\n4. **Style**: Follow style guide unless there's a compelling reason not to",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Common Conflict Scenarios",
        "content": "```\n**Scenario**: User wants to use pathlib in new code\n**Conflict**: Python Style Guide specifies os.path preference\n**Resolution**: Follow Python Style Guide - use os.path for consistency\n**Reasoning**: Project consistency takes priority over personal preference\n\n**Scenario**: User wants to use datetime.utcnow() in new code\n**Conflict**: Python Style Guide specifies datetime.now(datetime.UTC)\n**Resolution**: Follow Python Style Guide - use modern datetime approach\n**Reasoning**: Modern Python best practices take priority\n\n**Scenario**: User wants to use magic numbers in tests\n**Conflict**: Python Style Guide prohibits magic numbers, Testing Guide shows examples\n**Resolution**: Follow Python Style Guide - define constants for all magic numbers\n**Reasoning**: Consistency across all code (including tests) is important\n\n**Scenario**: User wants to use complex CSS selectors for HTML parsing\n**Conflict**: Web Scraping Patterns prefer simple, semantic selectors\n**Resolution**: Follow Web Scraping Patterns - use simple, resilient selectors\n**Reasoning**: Maintainability and resilience take priority over convenience\n\n**Scenario**: User wants to load configuration in each function\n**Conflict**: Python Style Guide specifies loading once at module level\n**Resolution**: Follow Python Style Guide - load configuration once at module level\n**Reasoning**: Performance and consistency take priority over convenience\n```",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Conflict Resolution Process",
        "content": "```\n1. **Identify the specific conflict** between guides\n2. **Apply the priority system**: Security → Project Consistency → Performance → Style\n3. **Explain the reasoning** behind the recommendation\n4. **Provide specific guidance** on how to implement the preferred approach\n5. **Acknowledge trade-offs** and explain why the chosen approach is better\n```",
        "subsections": []
      },
      {
        "level": 2,
        "title": "3. Context-Aware Suggestions",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "File Type Context",
        "content": "- **Configuration files**: Focus on clarity and maintainability\n- **Test files**: Focus on reliability and coverage\n- **API files**: Focus on security and performance\n- **Utility files**: Focus on reusability and documentation",
        "subsections": []
      },
      {
        "level": 3,
        "title": "User Context",
        "content": "- **Junior developers**: Provide more explanation and educational context\n- **Senior developers**: Focus on technical details and trade-offs\n- **New to project**: Emphasize project-specific patterns\n- **Experienced with project**: Focus on improvements and optimizations",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Task Context",
        "content": "- **Bug fixes**: Focus on correctness and preventing regressions\n- **New features**: Focus on maintainability and future-proofing\n- **Refactoring**: Focus on consistency and established patterns\n- **Performance work**: Focus on measurable improvements",
        "subsections": []
      },
      {
        "level": 2,
        "title": "4. Communication Patterns",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Positive Reinforcement",
        "content": "- **Acknowledge good practices**: \"Good use of type hints here\"\n- **Recognize progress**: \"This is much cleaner than the previous version\"\n- **Highlight improvements**: \"The error handling is now more robust\"",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Constructive Criticism",
        "content": "- **Focus on code, not person**: \"This approach could be improved\" vs \"You're doing this wrong\"\n- **Provide alternatives**: Always suggest specific improvements\n- **Explain reasoning**: Help user understand why changes are beneficial",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Educational Moments",
        "content": "- **Explain patterns**: \"This follows the [pattern name] which is preferred because...\"\n- **Share knowledge**: \"In Python, it's better to use X because...\"\n- **Provide context**: \"This is important because it affects...\"",
        "subsections": []
      },
      {
        "level": 2,
        "title": "5. Handling Different Types of Issues",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Style Violations",
        "content": "```\n**Issue**: Inconsistent import organization\n**Impact**: Reduces code readability and maintainability\n**Solution**: Reorganize imports following Python Style Guide order\n**Reasoning**: Consistent import organization makes code easier to scan and maintain\n```",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Performance Issues",
        "content": "```\n**Issue**: Redundant configuration loading in each function\n**Impact**: Unnecessary overhead and potential performance degradation\n**Solution**: Load configuration once at module level\n**Reasoning**: Reduces function call overhead and improves performance\n```",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Security Concerns",
        "content": "```\n**Issue**: Potential SQL injection vulnerability\n**Impact**: Security risk that could lead to data compromise\n**Solution**: Use parameterized queries with SQLAlchemy\n**Reasoning**: Parameterized queries prevent SQL injection attacks\n```",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Maintainability Issues",
        "content": "```\n**Issue**: Duplicated logic across multiple functions\n**Impact**: Makes maintenance harder and increases bug risk\n**Solution**: Extract common logic into a shared function\n**Reasoning**: DRY principle reduces code duplication and maintenance burden\n```",
        "subsections": []
      },
      {
        "level": 2,
        "title": "6. Review Scope Management",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "When to Expand Scope",
        "content": "- **Related issues**: If fixing one issue reveals related problems\n- **Pattern violations**: If the issue suggests a broader pattern problem\n- **User requests**: If user asks for broader review\n- **Critical issues**: If the issue affects multiple areas",
        "subsections": []
      },
      {
        "level": 3,
        "title": "When to Stay Focused",
        "content": "- **User's explicit scope**: Respect user's stated boundaries\n- **Unrelated issues**: Don't suggest changes outside current context\n- **Minor improvements**: Don't overwhelm with too many suggestions\n- **Future considerations**: Don't suggest premature optimizations",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Scope Communication",
        "content": "- **Current focus**: \"Focusing on the error handling in this function\"\n- **Related issues**: \"This also affects the similar function in X\"\n- **Broader implications**: \"This pattern appears in several other files\"\n- **Future considerations**: \"Consider applying this pattern elsewhere\"",
        "subsections": []
      },
      {
        "level": 2,
        "title": "7. Follow-up Patterns",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Checking Implementation",
        "content": "- **Verify changes**: Confirm that suggestions were implemented correctly\n- **Test integration**: Ensure changes work with the rest of the codebase\n- **Validate assumptions**: Check that the reasoning still applies\n- **Provide feedback**: Acknowledge good implementations",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Iterative Improvement",
        "content": "- **Build on progress**: Use previous improvements as foundation\n- **Incremental suggestions**: Don't suggest everything at once\n- **Learning opportunities**: Help user understand patterns for future use\n- **Confidence building**: Acknowledge improvements and progress",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Documentation Updates",
        "content": "- **Update guides**: If patterns evolve, update relevant guides\n- **Share learnings**: Document new patterns that work well\n- **Improve examples**: Update examples based on real usage\n- **Refine guidance**: Improve guidance based on user feedback",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Code Quality Standards",
        "content": "- **Readability**: Code should be self-documenting with clear variable and function names\n- **Consistency**: Follow established patterns and conventions throughout the codebase\n- **Maintainability**: Code should be easy to modify and extend without breaking existing functionality\n- **Performance**: Optimize for the specific use case while maintaining readability\n- **Security**: Follow security best practices and validate all inputs\n- **Testing**: Include comprehensive tests for all new functionality",
        "subsections": []
      },
      {
        "level": 3,
        "title": "AI Script Review Criteria",
        "content": "- **Linting Compliance**: All scripts must pass ruff, mypy, and other linting tools\n  - No E501 (line too long), B007 (unused variables), or PLR0911 (too many returns) errors\n  - Use underscore for unused loop variables (e.g., `for _ in range(1):`)\n  - Break complex functions into smaller, focused helper methods\n- **Report Generation**: Scripts should generate both human and machine-readable outputs\n  - Include Markdown reports with AI metadata and cross-references\n  - Provide JSON output for programmatic consumption\n  - Use consistent formatting and structure across all reports\n- **Error Handling**: Comprehensive error handling with detailed logging\n  - Collect errors in lists for batch reporting and analysis\n  - Provide both console output for immediate feedback and file output for persistence\n  - Include timestamps, error details, and resolution suggestions\n- **Performance**: Optimize for readability over performance in non-critical paths\n  - AI scripts are typically run infrequently, so maintainability is more important than speed\n  - Use clear, explicit logic even if it means multiple checks\n  - Prefer single return points for complex validation functions\n- **Maintainability**: Use helper methods to break down complex functions\n  - Extract complex logic into focused, well-named helper methods\n  - Use descriptive method names that clearly indicate their purpose\n  - Maintain clear separation of concerns between different functions\n- **Documentation**: Include AI metadata and cross-references in all generated content\n  - Use consistent AI metadata format across all generated reports\n  - Include bidirectional cross-references to related scripts and configuration\n  - Provide clear purpose, template version, and maintenance information\n\nThese criteria will inform AI script review and quality assurance throughout the project.\n\nAll AI scripts must meet these review criteria before being considered complete.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Review Process",
        "content": "",
        "subsections": []
      }
    ],
    "code_blocks": [
      {
        "language": "text",
        "code": "**Issue**: [Clear description of the problem]\n**Impact**: [Why this matters - performance, security, maintainability, etc.]\n**Solution**: [Specific, actionable fix]\n**Reasoning**: [Why this approach is preferred]"
      },
      {
        "language": "text",
        "code": "**Issue**: Magic number `5.0` used in performance assertion\n**Impact**: Reduces code readability and makes maintenance harder\n**Solution**: Define `MAX_PROCESSING_TIME_SECONDS = 5.0` at module level\n**Reasoning**: Follows Python Style Guide principle of avoiding magic numbers"
      },
      {
        "language": "text",
        "code": "## Critical Issues\n[Critical issues first]\n\n## High Priority Issues\n[Style guide violations, performance issues]\n\n## Medium Priority Issues\n[Code organization, documentation]\n\n## Suggestions for Future\n[Optional improvements]"
      },
      {
        "language": "text",
        "code": "**Scenario**: User wants to use pathlib in new code\n**Conflict**: Python Style Guide specifies os.path preference\n**Resolution**: Follow Python Style Guide - use os.path for consistency\n**Reasoning**: Project consistency takes priority over personal preference\n\n**Scenario**: User wants to use datetime.utcnow() in new code\n**Conflict**: Python Style Guide specifies datetime.now(datetime.UTC)\n**Resolution**: Follow Python Style Guide - use modern datetime approach\n**Reasoning**: Modern Python best practices take priority\n\n**Scenario**: User wants to use magic numbers in tests\n**Conflict**: Python Style Guide prohibits magic numbers, Testing Guide shows examples\n**Resolution**: Follow Python Style Guide - define constants for all magic numbers\n**Reasoning**: Consistency across all code (including tests) is important\n\n**Scenario**: User wants to use complex CSS selectors for HTML parsing\n**Conflict**: Web Scraping Patterns prefer simple, semantic selectors\n**Resolution**: Follow Web Scraping Patterns - use simple, resilient selectors\n**Reasoning**: Maintainability and resilience take priority over convenience\n\n**Scenario**: User wants to load configuration in each function\n**Conflict**: Python Style Guide specifies loading once at module level\n**Resolution**: Follow Python Style Guide - load configuration once at module level\n**Reasoning**: Performance and consistency take priority over convenience"
      },
      {
        "language": "text",
        "code": "1. **Identify the specific conflict** between guides\n2. **Apply the priority system**: Security → Project Consistency → Performance → Style\n3. **Explain the reasoning** behind the recommendation\n4. **Provide specific guidance** on how to implement the preferred approach\n5. **Acknowledge trade-offs** and explain why the chosen approach is better"
      },
      {
        "language": "text",
        "code": "**Issue**: Inconsistent import organization\n**Impact**: Reduces code readability and maintainability\n**Solution**: Reorganize imports following Python Style Guide order\n**Reasoning**: Consistent import organization makes code easier to scan and maintain"
      },
      {
        "language": "text",
        "code": "**Issue**: Redundant configuration loading in each function\n**Impact**: Unnecessary overhead and potential performance degradation\n**Solution**: Load configuration once at module level\n**Reasoning**: Reduces function call overhead and improves performance"
      },
      {
        "language": "text",
        "code": "**Issue**: Potential SQL injection vulnerability\n**Impact**: Security risk that could lead to data compromise\n**Solution**: Use parameterized queries with SQLAlchemy\n**Reasoning**: Parameterized queries prevent SQL injection attacks"
      },
      {
        "language": "text",
        "code": "**Issue**: Duplicated logic across multiple functions\n**Impact**: Makes maintenance harder and increases bug risk\n**Solution**: Extract common logic into a shared function\n**Reasoning**: DRY principle reduces code duplication and maintenance burden"
      }
    ],
    "links": [
      {
        "type": "code_reference",
        "text": "Core%20Principles.md"
      },
      {
        "type": "code_reference",
        "text": "../project_context/Common%20Patterns.md"
      },
      {
        "type": "code_reference",
        "text": "Language-Specific/Python%20Style%20Guide.md"
      },
      {
        "type": "code_reference",
        "text": "\n**Issue**: [Clear description of the problem]\n**Impact**: [Why this matters - performance, security, maintainability, etc.]\n**Solution**: [Specific, actionable fix]\n**Reasoning**: [Why this approach is preferred]\n"
      },
      {
        "type": "code_reference",
        "text": "\n\n## 2. Conflict Resolution\n\n### When Guides Conflict\n1. **Identify the conflict**: Clearly state what the guides say differently\n2. **Assess context**: Consider the specific situation and user's needs\n3. **Recommend approach**: Suggest which guide to follow and why\n4. **Explain trade-offs**: Help user understand the implications\n\n### Priority-Based Resolution\n1. **Security/Data Integrity**: Always follow strictest guidance\n2. **Project Consistency**: Follow established project patterns\n3. **Performance**: Use performance-focused guidance when relevant\n4. **Style**: Follow style guide unless there's a compelling reason not to\n\n### Common Conflict Scenarios\n"
      },
      {
        "type": "code_reference",
        "text": "\n**Scenario**: User wants to use pathlib in new code\n**Conflict**: Python Style Guide specifies os.path preference\n**Resolution**: Follow Python Style Guide - use os.path for consistency\n**Reasoning**: Project consistency takes priority over personal preference\n\n**Scenario**: User wants to use datetime.utcnow() in new code\n**Conflict**: Python Style Guide specifies datetime.now(datetime.UTC)\n**Resolution**: Follow Python Style Guide - use modern datetime approach\n**Reasoning**: Modern Python best practices take priority\n\n**Scenario**: User wants to use magic numbers in tests\n**Conflict**: Python Style Guide prohibits magic numbers, Testing Guide shows examples\n**Resolution**: Follow Python Style Guide - define constants for all magic numbers\n**Reasoning**: Consistency across all code (including tests) is important\n\n**Scenario**: User wants to use complex CSS selectors for HTML parsing\n**Conflict**: Web Scraping Patterns prefer simple, semantic selectors\n**Resolution**: Follow Web Scraping Patterns - use simple, resilient selectors\n**Reasoning**: Maintainability and resilience take priority over convenience\n\n**Scenario**: User wants to load configuration in each function\n**Conflict**: Python Style Guide specifies loading once at module level\n**Resolution**: Follow Python Style Guide - load configuration once at module level\n**Reasoning**: Performance and consistency take priority over convenience\n"
      },
      {
        "type": "code_reference",
        "text": "\n1. **Identify the specific conflict** between guides\n2. **Apply the priority system**: Security → Project Consistency → Performance → Style\n3. **Explain the reasoning** behind the recommendation\n4. **Provide specific guidance** on how to implement the preferred approach\n5. **Acknowledge trade-offs** and explain why the chosen approach is better\n"
      },
      {
        "type": "code_reference",
        "text": "\n\n## 3. Context-Aware Suggestions\n\n### File Type Context\n- **Configuration files**: Focus on clarity and maintainability\n- **Test files**: Focus on reliability and coverage\n- **API files**: Focus on security and performance\n- **Utility files**: Focus on reusability and documentation\n\n### User Context\n- **Junior developers**: Provide more explanation and educational context\n- **Senior developers**: Focus on technical details and trade-offs\n- **New to project**: Emphasize project-specific patterns\n- **Experienced with project**: Focus on improvements and optimizations\n\n### Task Context\n- **Bug fixes**: Focus on correctness and preventing regressions\n- **New features**: Focus on maintainability and future-proofing\n- **Refactoring**: Focus on consistency and established patterns\n- **Performance work**: Focus on measurable improvements\n\n## 4. Communication Patterns\n\n### Positive Reinforcement\n- **Acknowledge good practices**: \"Good use of type hints here\"\n- **Recognize progress**: \"This is much cleaner than the previous version\"\n- **Highlight improvements**: \"The error handling is now more robust\"\n\n### Constructive Criticism\n- **Focus on code, not person**: \"This approach could be improved\" vs \"You're doing this wrong\"\n- **Provide alternatives**: Always suggest specific improvements\n- **Explain reasoning**: Help user understand why changes are beneficial\n\n### Educational Moments\n- **Explain patterns**: \"This follows the [pattern name] which is preferred because...\"\n- **Share knowledge**: \"In Python, it's better to use X because...\"\n- **Provide context**: \"This is important because it affects...\"\n\n## 5. Handling Different Types of Issues\n\n### Style Violations\n"
      },
      {
        "type": "code_reference",
        "text": "\n\n## 6. Review Scope Management\n\n### When to Expand Scope\n- **Related issues**: If fixing one issue reveals related problems\n- **Pattern violations**: If the issue suggests a broader pattern problem\n- **User requests**: If user asks for broader review\n- **Critical issues**: If the issue affects multiple areas\n\n### When to Stay Focused\n- **User's explicit scope**: Respect user's stated boundaries\n- **Unrelated issues**: Don't suggest changes outside current context\n- **Minor improvements**: Don't overwhelm with too many suggestions\n- **Future considerations**: Don't suggest premature optimizations\n\n### Scope Communication\n- **Current focus**: \"Focusing on the error handling in this function\"\n- **Related issues**: \"This also affects the similar function in X\"\n- **Broader implications**: \"This pattern appears in several other files\"\n- **Future considerations**: \"Consider applying this pattern elsewhere\"\n\n## 7. Follow-up Patterns\n\n### Checking Implementation\n- **Verify changes**: Confirm that suggestions were implemented correctly\n- **Test integration**: Ensure changes work with the rest of the codebase\n- **Validate assumptions**: Check that the reasoning still applies\n- **Provide feedback**: Acknowledge good implementations\n\n### Iterative Improvement\n- **Build on progress**: Use previous improvements as foundation\n- **Incremental suggestions**: Don't suggest everything at once\n- **Learning opportunities**: Help user understand patterns for future use\n- **Confidence building**: Acknowledge improvements and progress\n\n### Documentation Updates\n- **Update guides**: If patterns evolve, update relevant guides\n- **Share learnings**: Document new patterns that work well\n- **Improve examples**: Update examples based on real usage\n- **Refine guidance**: Improve guidance based on user feedback\n\n### Code Quality Standards\n- **Readability**: Code should be self-documenting with clear variable and function names\n- **Consistency**: Follow established patterns and conventions throughout the codebase\n- **Maintainability**: Code should be easy to modify and extend without breaking existing functionality\n- **Performance**: Optimize for the specific use case while maintaining readability\n- **Security**: Follow security best practices and validate all inputs\n- **Testing**: Include comprehensive tests for all new functionality\n\n### AI Script Review Criteria\n- **Linting Compliance**: All scripts must pass ruff, mypy, and other linting tools\n  - No E501 (line too long), B007 (unused variables), or PLR0911 (too many returns) errors\n  - Use underscore for unused loop variables (e.g., "
      }
    ],
    "raw_content": "# Code Review Patterns\n\n> This guide provides comprehensive patterns and best practices for conducting effective code reviews. Use these patterns to ensure code quality, consistency, and maintainability.\n\n## AI Metadata\n\n**Template Version:** 2.1\n**AI Processing Level:** High\n**Required Context:** Code review processes, style guides, conflict resolution, user interaction patterns\n**Validation Required:** Yes\n**Code Generation:** Supported\n**Search Optimization:** Enhanced\n\n**Dependencies:**\n- `Core%20Principles.md` - Decision-making frameworks\n- `../project_context/Common%20Patterns.md` - Project-specific patterns\n- `Language-Specific/Python%20Style%20Guide.md` - Python coding standards\n- `Domain-Specific/` - Domain-specific patterns and guidelines\n\n**Validation Rules:**\n- All suggestions must follow the standard format\n- Priority system must be consistently applied\n- Context awareness must be maintained throughout\n- Communication patterns must be constructive and educational\n- Conflict resolution must follow established frameworks\n\n**Keywords:** code review, suggestions, conflict resolution, communication patterns, priority system, context awareness\n\n## 1. Suggestion Structure\n\n### Standard Suggestion Format\n```\n**Issue**: [Clear description of the problem]\n**Impact**: [Why this matters - performance, security, maintainability, etc.]\n**Solution**: [Specific, actionable fix]\n**Reasoning**: [Why this approach is preferred]\n```\n\n### Example Suggestion\n```\n**Issue**: Magic number `5.0` used in performance assertion\n**Impact**: Reduces code readability and makes maintenance harder\n**Solution**: Define `MAX_PROCESSING_TIME_SECONDS = 5.0` at module level\n**Reasoning**: Follows Python Style Guide principle of avoiding magic numbers\n```\n\n### Multi-Issue Reviews\nWhen multiple issues exist, structure them by priority:\n\n```\n## Critical Issues\n[Critical issues first]\n\n## High Priority Issues\n[Style guide violations, performance issues]\n\n## Medium Priority Issues\n[Code organization, documentation]\n\n## Suggestions for Future\n[Optional improvements]\n```\n\n## 2. Conflict Resolution\n\n### When Guides Conflict\n1. **Identify the conflict**: Clearly state what the guides say differently\n2. **Assess context**: Consider the specific situation and user's needs\n3. **Recommend approach**: Suggest which guide to follow and why\n4. **Explain trade-offs**: Help user understand the implications\n\n### Priority-Based Resolution\n1. **Security/Data Integrity**: Always follow strictest guidance\n2. **Project Consistency**: Follow established project patterns\n3. **Performance**: Use performance-focused guidance when relevant\n4. **Style**: Follow style guide unless there's a compelling reason not to\n\n### Common Conflict Scenarios\n```\n**Scenario**: User wants to use pathlib in new code\n**Conflict**: Python Style Guide specifies os.path preference\n**Resolution**: Follow Python Style Guide - use os.path for consistency\n**Reasoning**: Project consistency takes priority over personal preference\n\n**Scenario**: User wants to use datetime.utcnow() in new code\n**Conflict**: Python Style Guide specifies datetime.now(datetime.UTC)\n**Resolution**: Follow Python Style Guide - use modern datetime approach\n**Reasoning**: Modern Python best practices take priority\n\n**Scenario**: User wants to use magic numbers in tests\n**Conflict**: Python Style Guide prohibits magic numbers, Testing Guide shows examples\n**Resolution**: Follow Python Style Guide - define constants for all magic numbers\n**Reasoning**: Consistency across all code (including tests) is important\n\n**Scenario**: User wants to use complex CSS selectors for HTML parsing\n**Conflict**: Web Scraping Patterns prefer simple, semantic selectors\n**Resolution**: Follow Web Scraping Patterns - use simple, resilient selectors\n**Reasoning**: Maintainability and resilience take priority over convenience\n\n**Scenario**: User wants to load configuration in each function\n**Conflict**: Python Style Guide specifies loading once at module level\n**Resolution**: Follow Python Style Guide - load configuration once at module level\n**Reasoning**: Performance and consistency take priority over convenience\n```\n\n### Conflict Resolution Process\n```\n1. **Identify the specific conflict** between guides\n2. **Apply the priority system**: Security → Project Consistency → Performance → Style\n3. **Explain the reasoning** behind the recommendation\n4. **Provide specific guidance** on how to implement the preferred approach\n5. **Acknowledge trade-offs** and explain why the chosen approach is better\n```\n\n## 3. Context-Aware Suggestions\n\n### File Type Context\n- **Configuration files**: Focus on clarity and maintainability\n- **Test files**: Focus on reliability and coverage\n- **API files**: Focus on security and performance\n- **Utility files**: Focus on reusability and documentation\n\n### User Context\n- **Junior developers**: Provide more explanation and educational context\n- **Senior developers**: Focus on technical details and trade-offs\n- **New to project**: Emphasize project-specific patterns\n- **Experienced with project**: Focus on improvements and optimizations\n\n### Task Context\n- **Bug fixes**: Focus on correctness and preventing regressions\n- **New features**: Focus on maintainability and future-proofing\n- **Refactoring**: Focus on consistency and established patterns\n- **Performance work**: Focus on measurable improvements\n\n## 4. Communication Patterns\n\n### Positive Reinforcement\n- **Acknowledge good practices**: \"Good use of type hints here\"\n- **Recognize progress**: \"This is much cleaner than the previous version\"\n- **Highlight improvements**: \"The error handling is now more robust\"\n\n### Constructive Criticism\n- **Focus on code, not person**: \"This approach could be improved\" vs \"You're doing this wrong\"\n- **Provide alternatives**: Always suggest specific improvements\n- **Explain reasoning**: Help user understand why changes are beneficial\n\n### Educational Moments\n- **Explain patterns**: \"This follows the [pattern name] which is preferred because...\"\n- **Share knowledge**: \"In Python, it's better to use X because...\"\n- **Provide context**: \"This is important because it affects...\"\n\n## 5. Handling Different Types of Issues\n\n### Style Violations\n```\n**Issue**: Inconsistent import organization\n**Impact**: Reduces code readability and maintainability\n**Solution**: Reorganize imports following Python Style Guide order\n**Reasoning**: Consistent import organization makes code easier to scan and maintain\n```\n\n### Performance Issues\n```\n**Issue**: Redundant configuration loading in each function\n**Impact**: Unnecessary overhead and potential performance degradation\n**Solution**: Load configuration once at module level\n**Reasoning**: Reduces function call overhead and improves performance\n```\n\n### Security Concerns\n```\n**Issue**: Potential SQL injection vulnerability\n**Impact**: Security risk that could lead to data compromise\n**Solution**: Use parameterized queries with SQLAlchemy\n**Reasoning**: Parameterized queries prevent SQL injection attacks\n```\n\n### Maintainability Issues\n```\n**Issue**: Duplicated logic across multiple functions\n**Impact**: Makes maintenance harder and increases bug risk\n**Solution**: Extract common logic into a shared function\n**Reasoning**: DRY principle reduces code duplication and maintenance burden\n```\n\n## 6. Review Scope Management\n\n### When to Expand Scope\n- **Related issues**: If fixing one issue reveals related problems\n- **Pattern violations**: If the issue suggests a broader pattern problem\n- **User requests**: If user asks for broader review\n- **Critical issues**: If the issue affects multiple areas\n\n### When to Stay Focused\n- **User's explicit scope**: Respect user's stated boundaries\n- **Unrelated issues**: Don't suggest changes outside current context\n- **Minor improvements**: Don't overwhelm with too many suggestions\n- **Future considerations**: Don't suggest premature optimizations\n\n### Scope Communication\n- **Current focus**: \"Focusing on the error handling in this function\"\n- **Related issues**: \"This also affects the similar function in X\"\n- **Broader implications**: \"This pattern appears in several other files\"\n- **Future considerations**: \"Consider applying this pattern elsewhere\"\n\n## 7. Follow-up Patterns\n\n### Checking Implementation\n- **Verify changes**: Confirm that suggestions were implemented correctly\n- **Test integration**: Ensure changes work with the rest of the codebase\n- **Validate assumptions**: Check that the reasoning still applies\n- **Provide feedback**: Acknowledge good implementations\n\n### Iterative Improvement\n- **Build on progress**: Use previous improvements as foundation\n- **Incremental suggestions**: Don't suggest everything at once\n- **Learning opportunities**: Help user understand patterns for future use\n- **Confidence building**: Acknowledge improvements and progress\n\n### Documentation Updates\n- **Update guides**: If patterns evolve, update relevant guides\n- **Share learnings**: Document new patterns that work well\n- **Improve examples**: Update examples based on real usage\n- **Refine guidance**: Improve guidance based on user feedback\n\n### Code Quality Standards\n- **Readability**: Code should be self-documenting with clear variable and function names\n- **Consistency**: Follow established patterns and conventions throughout the codebase\n- **Maintainability**: Code should be easy to modify and extend without breaking existing functionality\n- **Performance**: Optimize for the specific use case while maintaining readability\n- **Security**: Follow security best practices and validate all inputs\n- **Testing**: Include comprehensive tests for all new functionality\n\n### AI Script Review Criteria\n- **Linting Compliance**: All scripts must pass ruff, mypy, and other linting tools\n  - No E501 (line too long), B007 (unused variables), or PLR0911 (too many returns) errors\n  - Use underscore for unused loop variables (e.g., `for _ in range(1):`)\n  - Break complex functions into smaller, focused helper methods\n- **Report Generation**: Scripts should generate both human and machine-readable outputs\n  - Include Markdown reports with AI metadata and cross-references\n  - Provide JSON output for programmatic consumption\n  - Use consistent formatting and structure across all reports\n- **Error Handling**: Comprehensive error handling with detailed logging\n  - Collect errors in lists for batch reporting and analysis\n  - Provide both console output for immediate feedback and file output for persistence\n  - Include timestamps, error details, and resolution suggestions\n- **Performance**: Optimize for readability over performance in non-critical paths\n  - AI scripts are typically run infrequently, so maintainability is more important than speed\n  - Use clear, explicit logic even if it means multiple checks\n  - Prefer single return points for complex validation functions\n- **Maintainability**: Use helper methods to break down complex functions\n  - Extract complex logic into focused, well-named helper methods\n  - Use descriptive method names that clearly indicate their purpose\n  - Maintain clear separation of concerns between different functions\n- **Documentation**: Include AI metadata and cross-references in all generated content\n  - Use consistent AI metadata format across all generated reports\n  - Include bidirectional cross-references to related scripts and configuration\n  - Provide clear purpose, template version, and maintenance information\n\nThese criteria will inform AI script review and quality assurance throughout the project.\n\nAll AI scripts must meet these review criteria before being considered complete.\n\n### Review Process\n"
  },
  "cross_references": [],
  "code_generation_hints": [
    {
      "context": "general",
      "hint": "These criteria will inform AI script review and quality assurance throughout the project.",
      "validation": ""
    }
  ],
  "validation_rules": [
    "All suggestions must follow the standard format",
    "**Report Generation**: Scripts should generate both human and machine-readable outputs\n  - Include Markdown reports with AI metadata and cross-references\n  - Provide JSON output for programmatic consumption\n  - Use consistent formatting and structure across all reports",
    "**Readability**: Code should be self-documenting with clear variable and function names",
    "Communication patterns must be constructive and educational",
    "Conflict resolution must follow established frameworks",
    "Priority system must be consistently applied",
    "**Maintainability**: Code should be easy to modify and extend without breaking existing functionality",
    "All AI scripts must meet these review criteria before being considered complete",
    "**Linting Compliance**: All scripts must pass ruff, mypy, and other linting tools\n  - No E501 (line too long), B007 (unused variables), or PLR0911 (too many returns) errors\n  - Use underscore for unused loop variables (e.g., `for _ in range(1):`)\n  - Break complex functions into smaller, focused helper methods",
    "Context awareness must be maintained throughout"
  ],
  "optimization": {
    "version": "1.0",
    "optimized_at": "2025-06-18T19:19:47.739662",
    "improvements": [
      "fixed_file_references",
      "extracted_ai_metadata",
      "structured_cross_references",
      "extracted_code_hints",
      "structured_validation_rules"
    ],
    "literal_strings_cleaned": true,
    "cleaned_at": "2025-06-18T19:30:00.000000"
  }
}