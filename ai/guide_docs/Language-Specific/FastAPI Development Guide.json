{
  "ai_metadata": {
    "purpose": "",
    "last_updated": "",
    "template_version": "2.1",
    "ai_tool_compatibility": "",
    "ai_processing_level": "High",
    "required_context": "FastAPI framework, async programming, API design patterns",
    "validation_required": "Yes",
    "code_generation": "Supported",
    "cross_references": [
      "../Core%20Principles.json",
      "../project_context/Common%20Patterns.json",
      "../project_context/Architecture%20Overview.json",
      "Python%20Style%20Guide.json",
      "Python%20Testing%20Guide.json"
    ],
    "maintenance": ""
  },
  "file_info": {
    "file_path": "guide_docs/Language-Specific/FastAPI Development Guide.md",
    "original_format": "markdown",
    "converted_at": "2025-06-18T19:14:30.249619",
    "file_size": 21691,
    "line_count": 672,
    "optimized_at": "2025-06-18T19:19:47.740924",
    "optimization_version": "1.0"
  },
  "content": {
    "sections": [
      {
        "level": 1,
        "title": "FastAPI Development Guide",
        "content": "> This guide provides comprehensive patterns and best practices for FastAPI development. Use these patterns to build robust, scalable API endpoints.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "AI Metadata",
        "content": "**Template Version:** 2.1\n**AI Processing Level:** High\n**Required Context:** FastAPI framework, async programming, API design patterns\n**Validation Required:** Yes\n**Code Generation:** Supported\n\n**Dependencies:**\n- `../Core%20Principles.json.replace(\".json\", \".json\")` - Decision-making frameworks\n- `../project_context/Common%20Patterns.json.replace(\".json\", \".json\")` - Project patterns\n- `../project_context/Architecture%20Overview.json.replace(\".json\", \".json\")` - System architecture\n- `Python%20Style%20Guide.json.replace(\".json\", \".json\")` - Python implementation patterns\n- `Python%20Testing%20Guide.json.replace(\".json\", \".json\")` - Testing patterns\n\n**Validation Rules:**\n- All endpoints must include proper type hints and response models\n- Error handling must follow established project patterns\n- Async/await must be used for all I/O operations\n- Pydantic models must be used for request/response validation\n- Testing must include both success and error cases",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Overview",
        "content": "**Document Purpose:** FastAPI development standards and best practices for the CreamPie project\n**Scope:** All API endpoints, routing, testing, and configuration\n**Target Users:** AI assistants and developers building FastAPI applications\n**Last Updated:** Current\n\n**AI Context:** This guide provides the foundational FastAPI development patterns that must be followed for all API development in the project. It ensures consistency, performance, and maintainability across all API endpoints.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "1. Route Handlers",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "General Guidelines",
        "content": "- Use async/await for route handlers\n- Include return type hints for all route handlers\n- Group related routes using FastAPI routers\n- Use descriptive route paths and HTTP methods\n- Document API endpoints with clear docstrings\n\nThese guidelines will inform all FastAPI endpoint implementation throughout the project.\n\nAll route handlers must follow these guidelines without exception.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Example Route Handler",
        "content": "```python\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom typing import List\n\nfrom ..db import get_async_db\nfrom ..models import User\nfrom ..schemas import UserResponse, UserCreate\n\nrouter = APIRouter()\n\n@router.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    db: AsyncSession = Depends(get_async_db)\n) -> UserResponse:\n    \"\"\"Get a user by their ID.\n\n    Args:\n        user_id: The ID of the user to retrieve\n        db: Database session dependency\n\n    Returns:\n        UserResponse: The requested user's data\n\n    Raises:\n        HTTPException: If the user is not found\n    \"\"\"\n    try:\n        user = await get_user_by_id(db, user_id)\n        if not user:\n            raise HTTPException(status_code=404, detail=\"User not found\")\n        return UserResponse.from_orm(user)\n    except Exception as e:\n        logger.error(f\"Error retrieving user {user_id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n```\n\nThis pattern will inform route handler implementation with proper error handling and response models.\n\nRoute handlers must include proper error handling, logging, and response model validation.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Router Organization Pattern",
        "content": "```python",
        "subsections": []
      },
      {
        "level": 1,
        "title": "In cream_api/stock_data/api.py",
        "content": "from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ..db import get_async_db\nfrom ..models import TrackedStock\nfrom ..schemas import StockRequestCreate, StockRequestResponse\nfrom ..tasks import update_all_tracked_stocks\n\nrouter = APIRouter(prefix=\"/stock-data\", tags=[\"Stock Data\"])\n\n@router.post(\"/track\", response_model=StockRequestResponse)\nasync def track_stock(\n    request: StockRequestCreate,\n    background_tasks: BackgroundTasks,\n    db: AsyncSession = Depends(get_async_db)\n) -> StockRequestResponse:\n    \"\"\"Add a new stock to tracking.\"\"\"\n    try:\n        # Business logic here\n        tracked_stock = await create_tracked_stock(db, request.symbol)\n\n        # Add background task\n        background_tasks.add_task(update_all_tracked_stocks)\n\n        return StockRequestResponse.from_orm(tracked_stock)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        logger.error(f\"Error tracking stock {request.symbol}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n```\n\nThis pattern will inform router organization and endpoint implementation with background tasks.\n\nRouters must include proper prefixes, tags, error handling, and background task integration.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "2. Configuration",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Settings Management",
        "content": "- Use Pydantic for settings management\n- Implement settings as a class inheriting from BaseSettings\n- Use environment variables for configuration\n- Cache configuration using lru_cache decorator\n- Keep configuration logic separate from application code\n\nThese patterns will inform configuration management throughout the project.\n\nConfiguration must use Pydantic models and environment variable support.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Example Settings Class",
        "content": "```python\nfrom pydantic_settings import BaseSettings\nfrom functools import lru_cache\nfrom typing import Optional\n\nclass AppSettings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n\n    # Database settings\n    DATABASE_URL: str\n    DATABASE_ECHO: bool = False\n\n    # API settings\n    API_V1_STR: str = \"/api/v1\"\n    PROJECT_NAME: str = \"Cream API\"\n    VERSION: str = \"1.0.0\"\n\n    # Security settings\n    SECRET_KEY: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    ALGORITHM: str = \"HS256\"\n\n    # CORS settings\n    BACKEND_CORS_ORIGINS: list[str] = [\"http://localhost:3000\"]\n\n    # Logging settings\n    LOG_LEVEL: str = \"INFO\"\n\n    class Config:\n        env_file = \".env\"\n        case_sensitive = True\n\n@lru_cache()\ndef get_settings() -> AppSettings:\n    \"\"\"Get cached application settings.\"\"\"\n    return AppSettings()\n```\n\nThis pattern will inform settings class structure with comprehensive configuration options.\n\nSettings must include all necessary configuration options and proper environment variable support.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Application Configuration",
        "content": "```python",
        "subsections": []
      },
      {
        "level": 1,
        "title": "In cream_api/main.py",
        "content": "from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom contextlib import asynccontextmanager\n\nfrom .settings import get_settings\nfrom .db import init_db\n\nsettings = get_settings()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan manager.\"\"\"\n    # Startup\n    await init_db()\n    yield\n    # Shutdown\n    # Cleanup code here\n\napp = FastAPI(\n    title=settings.PROJECT_NAME,\n    version=settings.VERSION,\n    lifespan=lifespan\n)",
        "subsections": []
      },
      {
        "level": 1,
        "title": "CORS middleware",
        "content": "app.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.BACKEND_CORS_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n```\n\nThis pattern will inform FastAPI application configuration with proper middleware and lifespan management.\n\nApplication configuration must include proper middleware, lifespan management, and CORS settings.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "3. Testing FastAPI Applications",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Test Application Setup",
        "content": "```python\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom ..main import app\nfrom ..db import get_async_db\nfrom ..models import Base",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Test database",
        "content": "TEST_DATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(TEST_DATABASE_URL, echo=False)\nTestingSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n@pytest.fixture\nasync def async_test_db():\n    \"\"\"Create test database session.\"\"\"\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with TestingSessionLocal() as session:\n        yield session\n\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n\n@pytest.fixture\ndef test_app(async_test_db: AsyncSession):\n    \"\"\"Create a test FastAPI application.\"\"\"\n    async def override_get_async_db():\n        yield async_test_db\n\n    app.dependency_overrides[get_async_db] = override_get_async_db\n    return app\n\n@pytest.fixture\ndef client(test_app):\n    \"\"\"Create test client.\"\"\"\n    return TestClient(test_app)\n```\n\nThis pattern will inform FastAPI testing setup with proper database fixtures and dependency overrides.\n\nTest setup must include proper database fixtures, dependency overrides, and test client creation.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Endpoint Testing",
        "content": "```python\nimport pytest\nfrom httpx import AsyncClient\n\n@pytest.mark.asyncio\nasync def test_get_user_success(client: TestClient, async_test_db: AsyncSession):\n    \"\"\"Test successful user retrieval.\"\"\"\n    # Setup test data\n    user = User(email=\"test@example.com\", username=\"testuser\")\n    async_test_db.add(user)\n    await async_test_db.commit()\n\n    # Test endpoint\n    response = client.get(f\"/users/{user.id}\")\n\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"email\"] == \"test@example.com\"\n    assert data[\"username\"] == \"testuser\"\n\n@pytest.mark.asyncio\nasync def test_get_user_not_found(client: TestClient):\n    \"\"\"Test user not found error.\"\"\"\n    response = client.get(\"/users/999\")\n\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n@pytest.mark.asyncio\nasync def test_create_user_success(client: TestClient):\n    \"\"\"Test successful user creation.\"\"\"\n    user_data = {\n        \"email\": \"new@example.com\",\n        \"username\": \"newuser\",\n        \"password\": \"securepassword\"\n    }\n\n    response = client.post(\"/users/\", json=user_data)\n\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"email\"] == user_data[\"email\"]\n    assert data[\"username\"] == user_data[\"username\"]\n```\n\nThis pattern will inform endpoint testing with comprehensive success and error case coverage.\n\nEndpoint tests must include both success and error cases with proper assertions.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Background Task Testing",
        "content": "```python\nfrom unittest.mock import patch\n\n@pytest.mark.asyncio\nasync def test_track_stock_with_background_task(client: TestClient):\n    \"\"\"Test stock tracking with background task.\"\"\"\n    with patch('cream_api.stock_data.api.update_all_tracked_stocks') as mock_task:\n        response = client.post(\"/stock-data/track\", json={\"symbol\": \"AAPL\"})\n\n        assert response.status_code == 200\n        mock_task.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_background_task_error_handling(client: TestClient):\n    \"\"\"Test background task error handling.\"\"\"\n    with patch('cream_api.stock_data.api.update_all_tracked_stocks') as mock_task:\n        mock_task.side_effect = Exception(\"Task failed\")\n\n        response = client.post(\"/stock-data/track\", json={\"symbol\": \"AAPL\"})\n\n        # Should still succeed even if background task fails\n        assert response.status_code == 200\n```\n\nThis pattern will inform background task testing with proper mocking and error handling.\n\nBackground task tests must include proper mocking and error handling scenarios.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "4. Pydantic Schema Patterns",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Request/Response Models",
        "content": "```python\nfrom pydantic import BaseModel, Field, validator\nfrom datetime import datetime\nfrom typing import Optional\n\nclass UserBase(BaseModel):\n    \"\"\"Base user model.\"\"\"\n    email: str = Field(..., description=\"User email address\")\n    username: str = Field(..., min_length=3, max_length=50, description=\"Username\")\n\nclass UserCreate(UserBase):\n    \"\"\"User creation model.\"\"\"\n    password: str = Field(..., min_length=8, description=\"User password\")\n\n    @validator('email')\n    def validate_email(cls, v):\n        if '@' not in v:\n            raise ValueError('Invalid email format')\n        return v.lower()\n\nclass UserResponse(UserBase):\n    \"\"\"User response model.\"\"\"\n    id: int\n    created_at: datetime\n    is_active: bool = True\n\n    class Config:\n        from_attributes = True\n\nclass StockRequestCreate(BaseModel):\n    \"\"\"Stock tracking request model.\"\"\"\n    symbol: str = Field(..., min_length=1, max_length=10, regex=r'^[A-Z]+$')\n\n    @validator('symbol')\n    def validate_symbol(cls, v):\n        return v.upper()\n\nclass StockRequestResponse(BaseModel):\n    \"\"\"Stock tracking response model.\"\"\"\n    id: int\n    symbol: str\n    is_active: bool\n    last_pull_date: Optional[datetime] = None\n\n    class Config:\n        from_attributes = True\n```\n\nThis pattern will inform Pydantic model structure with proper validation and configuration.\n\nPydantic models must include proper field validation, descriptions, and ORM compatibility.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Error Response Models",
        "content": "```python\nfrom pydantic import BaseModel\nfrom typing import Optional, Any\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response model.\"\"\"\n    detail: str\n    error_code: Optional[str] = None\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n\nclass ValidationErrorResponse(BaseModel):\n    \"\"\"Validation error response model.\"\"\"\n    detail: list[dict[str, Any]]\n    error_code: str = \"VALIDATION_ERROR\"\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n```\n\nThis pattern will inform error response model structure for consistent error handling.\n\nError response models must include proper error details and timestamps.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "5. Dependency Injection Patterns",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Database Dependencies",
        "content": "```python\nfrom fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ..db import get_async_db\n\nasync def get_current_user(\n    db: AsyncSession = Depends(get_async_db),\n    token: str = Depends(oauth2_scheme)\n) -> User:\n    \"\"\"Get current authenticated user.\"\"\"\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        user_id: int = payload.get(\"sub\")\n        if user_id is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n    user = await get_user_by_id(db, user_id)\n    if user is None:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n    return user\n\nasync def require_admin(\n    current_user: User = Depends(get_current_user)\n) -> User:\n    \"\"\"Require admin privileges.\"\"\"\n    if not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"Admin privileges required\")\n    return current_user\n```\n\nThis pattern will inform dependency injection implementation for authentication and authorization.\n\nDependencies must include proper error handling and type hints.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Service Dependencies",
        "content": "```python\nfrom typing import Annotated",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Service dependency",
        "content": "async def get_stock_service(\n    db: AsyncSession = Depends(get_async_db)\n) -> StockService:\n    \"\"\"Get stock service instance.\"\"\"\n    return StockService(db)",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Use in endpoints",
        "content": "@router.get(\"/stocks/{symbol}\")\nasync def get_stock(\n    symbol: str,\n    stock_service: Annotated[StockService, Depends(get_stock_service)]\n) -> StockResponse:\n    \"\"\"Get stock data using service dependency.\"\"\"\n    return await stock_service.get_stock(symbol)\n```\n\nThis pattern will inform service dependency injection for business logic separation.\n\nService dependencies must include proper type hints and error handling.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "6. Middleware and Exception Handling",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Custom Exception Handler",
        "content": "```python\nfrom fastapi import Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(\n    request: Request,\n    exc: RequestValidationError\n) -> JSONResponse:\n    \"\"\"Handle validation errors.\"\"\"\n    return JSONResponse(\n        status_code=422,\n        content={\n            \"detail\": exc.errors(),\n            \"error_code\": \"VALIDATION_ERROR\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )\n\n@app.exception_handler(Exception)\nasync def general_exception_handler(\n    request: Request,\n    exc: Exception\n) -> JSONResponse:\n    \"\"\"Handle general exceptions.\"\"\"\n    logger.error(f\"Unhandled exception: {exc}\")\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"detail\": \"Internal server error\",\n            \"error_code\": \"INTERNAL_ERROR\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )\n```\n\nThis pattern will inform exception handler implementation for consistent error responses.\n\nException handlers must include proper logging and consistent error response format.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Custom Middleware",
        "content": "```python\nimport time\nfrom fastapi import Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Logging middleware for request/response tracking.\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n\n        # Log request\n        logger.info(f\"Request: {request.method} {request.url}\")\n\n        response = await call_next(request)\n\n        # Log response\n        process_time = time.time() - start_time\n        logger.info(f\"Response: {response.status_code} - {process_time:.3f}s\")\n\n        return response",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Add middleware to app",
        "content": "app.add_middleware(LoggingMiddleware)\n```\n\nThis pattern will inform custom middleware implementation for logging and monitoring.\n\nMiddleware must include proper logging and performance tracking.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "7. Background Tasks Integration",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Task Definition and Usage",
        "content": "```python\nfrom fastapi import BackgroundTasks\nfrom typing import List\n\nasync def send_email_notification(user_id: int, message: str) -> None:\n    \"\"\"Send email notification (background task).\"\"\"\n    try:\n        # Email sending logic here\n        logger.info(f\"Email sent to user {user_id}: {message}\")\n    except Exception as e:\n        logger.error(f\"Failed to send email to user {user_id}: {e}\")\n\nasync def process_data_batch(data: List[dict]) -> None:\n    \"\"\"Process data batch (background task).\"\"\"\n    try:\n        for item in data:\n            await process_single_item(item)\n        logger.info(f\"Processed {len(data)} items\")\n    except Exception as e:\n        logger.error(f\"Failed to process data batch: {e}\")\n\n@router.post(\"/users/{user_id}/notify\")\nasync def notify_user(\n    user_id: int,\n    message: str,\n    background_tasks: BackgroundTasks\n) -> dict:\n    \"\"\"Send notification to user with background task.\"\"\"\n    background_tasks.add_task(send_email_notification, user_id, message)\n\n    return {\"message\": \"Notification scheduled\"}\n```\n\nThis pattern will inform background task implementation and usage in endpoints.\n\nBackground tasks must include proper error handling and logging.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Implementation Guidelines",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "For AI Assistants",
        "content": "1. **Follow this guide** for all FastAPI development\n2. **Use async/await** for all route handlers\n3. **Include type hints** for all functions and parameters\n4. **Use Pydantic models** for request/response validation\n5. **Implement proper error handling** with custom exceptions\n6. **Write comprehensive tests** for all endpoints\n7. **Use dependency injection** for service separation\n8. **Include background tasks** for long-running operations",
        "subsections": []
      },
      {
        "level": 3,
        "title": "For Human Developers",
        "content": "1. **Reference this guide** when building FastAPI applications\n2. **Use async/await** for better performance\n3. **Write comprehensive tests** for all endpoints\n4. **Follow established patterns** for consistency\n5. **Use Pydantic models** for data validation\n6. **Implement proper error handling** and logging\n7. **Use dependency injection** for maintainability",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Quality Assurance",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "API Quality Standards",
        "content": "- All endpoints must include proper type hints and response models\n- Error handling must be comprehensive and consistent\n- Async/await must be used for all I/O operations\n- Pydantic models must be used for validation\n- Background tasks must include proper error handling",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Testing Requirements",
        "content": "- All endpoints must have unit tests\n- Tests must cover both success and error cases\n- Background tasks must be tested with proper mocking\n- Integration tests must include database operations",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Documentation Standards",
        "content": "- All endpoints must include comprehensive docstrings\n- API documentation must be generated with OpenAPI\n- Examples must be provided for all endpoints\n- Error responses must be documented",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Performance Considerations",
        "content": "- Use async/await for all I/O operations\n- Implement proper caching strategies\n- Use background tasks for long-running operations\n- Monitor API performance and response times\n\n---\n\n**AI Quality Checklist**: Before implementing FastAPI endpoints, ensure:\n- [x] Async/await is used for all route handlers\n- [x] Type hints are included for all functions and parameters\n- [x] Pydantic models are used for request/response validation\n- [x] Error handling is comprehensive and consistent\n- [x] Background tasks are used for long-running operations\n- [x] Tests are written for all endpoints\n- [x] Documentation is comprehensive and accurate\n- [x] Performance considerations are addressed",
        "subsections": []
      }
    ],
    "code_blocks": [
      {
        "language": "python",
        "code": "from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom typing import List\n\nfrom ..db import get_async_db\nfrom ..models import User\nfrom ..schemas import UserResponse, UserCreate\n\nrouter = APIRouter()\n\n@router.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    db: AsyncSession = Depends(get_async_db)\n) -> UserResponse:\n    \"\"\"Get a user by their ID.\n\n    Args:\n        user_id: The ID of the user to retrieve\n        db: Database session dependency\n\n    Returns:\n        UserResponse: The requested user's data\n\n    Raises:\n        HTTPException: If the user is not found\n    \"\"\"\n    try:\n        user = await get_user_by_id(db, user_id)\n        if not user:\n            raise HTTPException(status_code=404, detail=\"User not found\")\n        return UserResponse.from_orm(user)\n    except Exception as e:\n        logger.error(f\"Error retrieving user {user_id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")"
      },
      {
        "language": "python",
        "code": "# In cream_api/stock_data/api.py\nfrom fastapi import APIRouter, Depends, HTTPException, BackgroundTasks\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ..db import get_async_db\nfrom ..models import TrackedStock\nfrom ..schemas import StockRequestCreate, StockRequestResponse\nfrom ..tasks import update_all_tracked_stocks\n\nrouter = APIRouter(prefix=\"/stock-data\", tags=[\"Stock Data\"])\n\n@router.post(\"/track\", response_model=StockRequestResponse)\nasync def track_stock(\n    request: StockRequestCreate,\n    background_tasks: BackgroundTasks,\n    db: AsyncSession = Depends(get_async_db)\n) -> StockRequestResponse:\n    \"\"\"Add a new stock to tracking.\"\"\"\n    try:\n        # Business logic here\n        tracked_stock = await create_tracked_stock(db, request.symbol)\n\n        # Add background task\n        background_tasks.add_task(update_all_tracked_stocks)\n\n        return StockRequestResponse.from_orm(tracked_stock)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        logger.error(f\"Error tracking stock {request.symbol}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")"
      },
      {
        "language": "python",
        "code": "from pydantic_settings import BaseSettings\nfrom functools import lru_cache\nfrom typing import Optional\n\nclass AppSettings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n\n    # Database settings\n    DATABASE_URL: str\n    DATABASE_ECHO: bool = False\n\n    # API settings\n    API_V1_STR: str = \"/api/v1\"\n    PROJECT_NAME: str = \"Cream API\"\n    VERSION: str = \"1.0.0\"\n\n    # Security settings\n    SECRET_KEY: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    ALGORITHM: str = \"HS256\"\n\n    # CORS settings\n    BACKEND_CORS_ORIGINS: list[str] = [\"http://localhost:3000\"]\n\n    # Logging settings\n    LOG_LEVEL: str = \"INFO\"\n\n    class Config:\n        env_file = \".env\"\n        case_sensitive = True\n\n@lru_cache()\ndef get_settings() -> AppSettings:\n    \"\"\"Get cached application settings.\"\"\"\n    return AppSettings()"
      },
      {
        "language": "python",
        "code": "# In cream_api/main.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom contextlib import asynccontextmanager\n\nfrom .settings import get_settings\nfrom .db import init_db\n\nsettings = get_settings()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan manager.\"\"\"\n    # Startup\n    await init_db()\n    yield\n    # Shutdown\n    # Cleanup code here\n\napp = FastAPI(\n    title=settings.PROJECT_NAME,\n    version=settings.VERSION,\n    lifespan=lifespan\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.BACKEND_CORS_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)"
      },
      {
        "language": "python",
        "code": "import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom ..main import app\nfrom ..db import get_async_db\nfrom ..models import Base\n\n# Test database\nTEST_DATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(TEST_DATABASE_URL, echo=False)\nTestingSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n@pytest.fixture\nasync def async_test_db():\n    \"\"\"Create test database session.\"\"\"\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with TestingSessionLocal() as session:\n        yield session\n\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n\n@pytest.fixture\ndef test_app(async_test_db: AsyncSession):\n    \"\"\"Create a test FastAPI application.\"\"\"\n    async def override_get_async_db():\n        yield async_test_db\n\n    app.dependency_overrides[get_async_db] = override_get_async_db\n    return app\n\n@pytest.fixture\ndef client(test_app):\n    \"\"\"Create test client.\"\"\"\n    return TestClient(test_app)"
      },
      {
        "language": "python",
        "code": "import pytest\nfrom httpx import AsyncClient\n\n@pytest.mark.asyncio\nasync def test_get_user_success(client: TestClient, async_test_db: AsyncSession):\n    \"\"\"Test successful user retrieval.\"\"\"\n    # Setup test data\n    user = User(email=\"test@example.com\", username=\"testuser\")\n    async_test_db.add(user)\n    await async_test_db.commit()\n\n    # Test endpoint\n    response = client.get(f\"/users/{user.id}\")\n\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"email\"] == \"test@example.com\"\n    assert data[\"username\"] == \"testuser\"\n\n@pytest.mark.asyncio\nasync def test_get_user_not_found(client: TestClient):\n    \"\"\"Test user not found error.\"\"\"\n    response = client.get(\"/users/999\")\n\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n@pytest.mark.asyncio\nasync def test_create_user_success(client: TestClient):\n    \"\"\"Test successful user creation.\"\"\"\n    user_data = {\n        \"email\": \"new@example.com\",\n        \"username\": \"newuser\",\n        \"password\": \"securepassword\"\n    }\n\n    response = client.post(\"/users/\", json=user_data)\n\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"email\"] == user_data[\"email\"]\n    assert data[\"username\"] == user_data[\"username\"]"
      },
      {
        "language": "python",
        "code": "from unittest.mock import patch\n\n@pytest.mark.asyncio\nasync def test_track_stock_with_background_task(client: TestClient):\n    \"\"\"Test stock tracking with background task.\"\"\"\n    with patch('cream_api.stock_data.api.update_all_tracked_stocks') as mock_task:\n        response = client.post(\"/stock-data/track\", json={\"symbol\": \"AAPL\"})\n\n        assert response.status_code == 200\n        mock_task.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_background_task_error_handling(client: TestClient):\n    \"\"\"Test background task error handling.\"\"\"\n    with patch('cream_api.stock_data.api.update_all_tracked_stocks') as mock_task:\n        mock_task.side_effect = Exception(\"Task failed\")\n\n        response = client.post(\"/stock-data/track\", json={\"symbol\": \"AAPL\"})\n\n        # Should still succeed even if background task fails\n        assert response.status_code == 200"
      },
      {
        "language": "python",
        "code": "from pydantic import BaseModel, Field, validator\nfrom datetime import datetime\nfrom typing import Optional\n\nclass UserBase(BaseModel):\n    \"\"\"Base user model.\"\"\"\n    email: str = Field(..., description=\"User email address\")\n    username: str = Field(..., min_length=3, max_length=50, description=\"Username\")\n\nclass UserCreate(UserBase):\n    \"\"\"User creation model.\"\"\"\n    password: str = Field(..., min_length=8, description=\"User password\")\n\n    @validator('email')\n    def validate_email(cls, v):\n        if '@' not in v:\n            raise ValueError('Invalid email format')\n        return v.lower()\n\nclass UserResponse(UserBase):\n    \"\"\"User response model.\"\"\"\n    id: int\n    created_at: datetime\n    is_active: bool = True\n\n    class Config:\n        from_attributes = True\n\nclass StockRequestCreate(BaseModel):\n    \"\"\"Stock tracking request model.\"\"\"\n    symbol: str = Field(..., min_length=1, max_length=10, regex=r'^[A-Z]+$')\n\n    @validator('symbol')\n    def validate_symbol(cls, v):\n        return v.upper()\n\nclass StockRequestResponse(BaseModel):\n    \"\"\"Stock tracking response model.\"\"\"\n    id: int\n    symbol: str\n    is_active: bool\n    last_pull_date: Optional[datetime] = None\n\n    class Config:\n        from_attributes = True"
      },
      {
        "language": "python",
        "code": "from pydantic import BaseModel\nfrom typing import Optional, Any\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response model.\"\"\"\n    detail: str\n    error_code: Optional[str] = None\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n\nclass ValidationErrorResponse(BaseModel):\n    \"\"\"Validation error response model.\"\"\"\n    detail: list[dict[str, Any]]\n    error_code: str = \"VALIDATION_ERROR\"\n    timestamp: datetime = Field(default_factory=datetime.utcnow)"
      },
      {
        "language": "python",
        "code": "from fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ..db import get_async_db\n\nasync def get_current_user(\n    db: AsyncSession = Depends(get_async_db),\n    token: str = Depends(oauth2_scheme)\n) -> User:\n    \"\"\"Get current authenticated user.\"\"\"\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        user_id: int = payload.get(\"sub\")\n        if user_id is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n    user = await get_user_by_id(db, user_id)\n    if user is None:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n    return user\n\nasync def require_admin(\n    current_user: User = Depends(get_current_user)\n) -> User:\n    \"\"\"Require admin privileges.\"\"\"\n    if not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"Admin privileges required\")\n    return current_user"
      },
      {
        "language": "python",
        "code": "from typing import Annotated\n\n# Service dependency\nasync def get_stock_service(\n    db: AsyncSession = Depends(get_async_db)\n) -> StockService:\n    \"\"\"Get stock service instance.\"\"\"\n    return StockService(db)\n\n# Use in endpoints\n@router.get(\"/stocks/{symbol}\")\nasync def get_stock(\n    symbol: str,\n    stock_service: Annotated[StockService, Depends(get_stock_service)]\n) -> StockResponse:\n    \"\"\"Get stock data using service dependency.\"\"\"\n    return await stock_service.get_stock(symbol)"
      },
      {
        "language": "python",
        "code": "from fastapi import Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(\n    request: Request,\n    exc: RequestValidationError\n) -> JSONResponse:\n    \"\"\"Handle validation errors.\"\"\"\n    return JSONResponse(\n        status_code=422,\n        content={\n            \"detail\": exc.errors(),\n            \"error_code\": \"VALIDATION_ERROR\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )\n\n@app.exception_handler(Exception)\nasync def general_exception_handler(\n    request: Request,\n    exc: Exception\n) -> JSONResponse:\n    \"\"\"Handle general exceptions.\"\"\"\n    logger.error(f\"Unhandled exception: {exc}\")\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"detail\": \"Internal server error\",\n            \"error_code\": \"INTERNAL_ERROR\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )"
      },
      {
        "language": "python",
        "code": "import time\nfrom fastapi import Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Logging middleware for request/response tracking.\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n\n        # Log request\n        logger.info(f\"Request: {request.method} {request.url}\")\n\n        response = await call_next(request)\n\n        # Log response\n        process_time = time.time() - start_time\n        logger.info(f\"Response: {response.status_code} - {process_time:.3f}s\")\n\n        return response\n\n# Add middleware to app\napp.add_middleware(LoggingMiddleware)"
      },
      {
        "language": "python",
        "code": "from fastapi import BackgroundTasks\nfrom typing import List\n\nasync def send_email_notification(user_id: int, message: str) -> None:\n    \"\"\"Send email notification (background task).\"\"\"\n    try:\n        # Email sending logic here\n        logger.info(f\"Email sent to user {user_id}: {message}\")\n    except Exception as e:\n        logger.error(f\"Failed to send email to user {user_id}: {e}\")\n\nasync def process_data_batch(data: List[dict]) -> None:\n    \"\"\"Process data batch (background task).\"\"\"\n    try:\n        for item in data:\n            await process_single_item(item)\n        logger.info(f\"Processed {len(data)} items\")\n    except Exception as e:\n        logger.error(f\"Failed to process data batch: {e}\")\n\n@router.post(\"/users/{user_id}/notify\")\nasync def notify_user(\n    user_id: int,\n    message: str,\n    background_tasks: BackgroundTasks\n) -> dict:\n    \"\"\"Send notification to user with background task.\"\"\"\n    background_tasks.add_task(send_email_notification, user_id, message)\n\n    return {\"message\": \"Notification scheduled\"}"
      }
    ],
    "links": [
      {
        "type": "code_reference",
        "text": "../Core%20Principles.md"
      },
      {
        "type": "code_reference",
        "text": "../project_context/Common%20Patterns.md"
      },
      {
        "type": "code_reference",
        "text": "../project_context/Architecture%20Overview.md"
      },
      {
        "type": "code_reference",
        "text": "Python%20Style%20Guide.md"
      },
      {
        "type": "code_reference",
        "text": "Python%20Testing%20Guide.md"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom typing import List\n\nfrom ..db import get_async_db\nfrom ..models import User\nfrom ..schemas import UserResponse, UserCreate\n\nrouter = APIRouter()\n\n@router.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    db: AsyncSession = Depends(get_async_db)\n) -> UserResponse:\n    \"\"\"Get a user by their ID.\n\n    Args:\n        user_id: The ID of the user to retrieve\n        db: Database session dependency\n\n    Returns:\n        UserResponse: The requested user's data\n\n    Raises:\n        HTTPException: If the user is not found\n    \"\"\"\n    try:\n        user = await get_user_by_id(db, user_id)\n        if not user:\n            raise HTTPException(status_code=404, detail=\"User not found\")\n        return UserResponse.from_orm(user)\n    except Exception as e:\n        logger.error(f\"Error retrieving user {user_id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform route handler implementation with proper error handling and response models.\n\nRoute handlers must include proper error handling, logging, and response model validation.\n\n### Router Organization Pattern\n"
      },
      {
        "type": "code_reference",
        "text": "python\n# In cream_api/stock_data/api.py\nfrom fastapi import APIRouter, Depends, HTTPException, BackgroundTasks\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ..db import get_async_db\nfrom ..models import TrackedStock\nfrom ..schemas import StockRequestCreate, StockRequestResponse\nfrom ..tasks import update_all_tracked_stocks\n\nrouter = APIRouter(prefix=\"/stock-data\", tags=[\"Stock Data\"])\n\n@router.post(\"/track\", response_model=StockRequestResponse)\nasync def track_stock(\n    request: StockRequestCreate,\n    background_tasks: BackgroundTasks,\n    db: AsyncSession = Depends(get_async_db)\n) -> StockRequestResponse:\n    \"\"\"Add a new stock to tracking.\"\"\"\n    try:\n        # Business logic here\n        tracked_stock = await create_tracked_stock(db, request.symbol)\n\n        # Add background task\n        background_tasks.add_task(update_all_tracked_stocks)\n\n        return StockRequestResponse.from_orm(tracked_stock)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        logger.error(f\"Error tracking stock {request.symbol}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform router organization and endpoint implementation with background tasks.\n\nRouters must include proper prefixes, tags, error handling, and background task integration.\n\n## 2. Configuration\n\n### Settings Management\n- Use Pydantic for settings management\n- Implement settings as a class inheriting from BaseSettings\n- Use environment variables for configuration\n- Cache configuration using lru_cache decorator\n- Keep configuration logic separate from application code\n\nThese patterns will inform configuration management throughout the project.\n\nConfiguration must use Pydantic models and environment variable support.\n\n### Example Settings Class\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom pydantic_settings import BaseSettings\nfrom functools import lru_cache\nfrom typing import Optional\n\nclass AppSettings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n\n    # Database settings\n    DATABASE_URL: str\n    DATABASE_ECHO: bool = False\n\n    # API settings\n    API_V1_STR: str = \"/api/v1\"\n    PROJECT_NAME: str = \"Cream API\"\n    VERSION: str = \"1.0.0\"\n\n    # Security settings\n    SECRET_KEY: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    ALGORITHM: str = \"HS256\"\n\n    # CORS settings\n    BACKEND_CORS_ORIGINS: list[str] = [\"http://localhost:3000\"]\n\n    # Logging settings\n    LOG_LEVEL: str = \"INFO\"\n\n    class Config:\n        env_file = \".env\"\n        case_sensitive = True\n\n@lru_cache()\ndef get_settings() -> AppSettings:\n    \"\"\"Get cached application settings.\"\"\"\n    return AppSettings()\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform settings class structure with comprehensive configuration options.\n\nSettings must include all necessary configuration options and proper environment variable support.\n\n### Application Configuration\n"
      },
      {
        "type": "code_reference",
        "text": "python\n# In cream_api/main.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom contextlib import asynccontextmanager\n\nfrom .settings import get_settings\nfrom .db import init_db\n\nsettings = get_settings()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan manager.\"\"\"\n    # Startup\n    await init_db()\n    yield\n    # Shutdown\n    # Cleanup code here\n\napp = FastAPI(\n    title=settings.PROJECT_NAME,\n    version=settings.VERSION,\n    lifespan=lifespan\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.BACKEND_CORS_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform FastAPI application configuration with proper middleware and lifespan management.\n\nApplication configuration must include proper middleware, lifespan management, and CORS settings.\n\n## 3. Testing FastAPI Applications\n\n### Test Application Setup\n"
      },
      {
        "type": "code_reference",
        "text": "python\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom ..main import app\nfrom ..db import get_async_db\nfrom ..models import Base\n\n# Test database\nTEST_DATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(TEST_DATABASE_URL, echo=False)\nTestingSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n@pytest.fixture\nasync def async_test_db():\n    \"\"\"Create test database session.\"\"\"\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with TestingSessionLocal() as session:\n        yield session\n\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n\n@pytest.fixture\ndef test_app(async_test_db: AsyncSession):\n    \"\"\"Create a test FastAPI application.\"\"\"\n    async def override_get_async_db():\n        yield async_test_db\n\n    app.dependency_overrides[get_async_db] = override_get_async_db\n    return app\n\n@pytest.fixture\ndef client(test_app):\n    \"\"\"Create test client.\"\"\"\n    return TestClient(test_app)\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform FastAPI testing setup with proper database fixtures and dependency overrides.\n\nTest setup must include proper database fixtures, dependency overrides, and test client creation.\n\n### Endpoint Testing\n"
      },
      {
        "type": "code_reference",
        "text": "python\nimport pytest\nfrom httpx import AsyncClient\n\n@pytest.mark.asyncio\nasync def test_get_user_success(client: TestClient, async_test_db: AsyncSession):\n    \"\"\"Test successful user retrieval.\"\"\"\n    # Setup test data\n    user = User(email=\"test@example.com\", username=\"testuser\")\n    async_test_db.add(user)\n    await async_test_db.commit()\n\n    # Test endpoint\n    response = client.get(f\"/users/{user.id}\")\n\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"email\"] == \"test@example.com\"\n    assert data[\"username\"] == \"testuser\"\n\n@pytest.mark.asyncio\nasync def test_get_user_not_found(client: TestClient):\n    \"\"\"Test user not found error.\"\"\"\n    response = client.get(\"/users/999\")\n\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n@pytest.mark.asyncio\nasync def test_create_user_success(client: TestClient):\n    \"\"\"Test successful user creation.\"\"\"\n    user_data = {\n        \"email\": \"new@example.com\",\n        \"username\": \"newuser\",\n        \"password\": \"securepassword\"\n    }\n\n    response = client.post(\"/users/\", json=user_data)\n\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"email\"] == user_data[\"email\"]\n    assert data[\"username\"] == user_data[\"username\"]\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform endpoint testing with comprehensive success and error case coverage.\n\nEndpoint tests must include both success and error cases with proper assertions.\n\n### Background Task Testing\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom unittest.mock import patch\n\n@pytest.mark.asyncio\nasync def test_track_stock_with_background_task(client: TestClient):\n    \"\"\"Test stock tracking with background task.\"\"\"\n    with patch('cream_api.stock_data.api.update_all_tracked_stocks') as mock_task:\n        response = client.post(\"/stock-data/track\", json={\"symbol\": \"AAPL\"})\n\n        assert response.status_code == 200\n        mock_task.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_background_task_error_handling(client: TestClient):\n    \"\"\"Test background task error handling.\"\"\"\n    with patch('cream_api.stock_data.api.update_all_tracked_stocks') as mock_task:\n        mock_task.side_effect = Exception(\"Task failed\")\n\n        response = client.post(\"/stock-data/track\", json={\"symbol\": \"AAPL\"})\n\n        # Should still succeed even if background task fails\n        assert response.status_code == 200\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform background task testing with proper mocking and error handling.\n\nBackground task tests must include proper mocking and error handling scenarios.\n\n## 4. Pydantic Schema Patterns\n\n### Request/Response Models\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom pydantic import BaseModel, Field, validator\nfrom datetime import datetime\nfrom typing import Optional\n\nclass UserBase(BaseModel):\n    \"\"\"Base user model.\"\"\"\n    email: str = Field(..., description=\"User email address\")\n    username: str = Field(..., min_length=3, max_length=50, description=\"Username\")\n\nclass UserCreate(UserBase):\n    \"\"\"User creation model.\"\"\"\n    password: str = Field(..., min_length=8, description=\"User password\")\n\n    @validator('email')\n    def validate_email(cls, v):\n        if '@' not in v:\n            raise ValueError('Invalid email format')\n        return v.lower()\n\nclass UserResponse(UserBase):\n    \"\"\"User response model.\"\"\"\n    id: int\n    created_at: datetime\n    is_active: bool = True\n\n    class Config:\n        from_attributes = True\n\nclass StockRequestCreate(BaseModel):\n    \"\"\"Stock tracking request model.\"\"\"\n    symbol: str = Field(..., min_length=1, max_length=10, regex=r'^[A-Z]+$')\n\n    @validator('symbol')\n    def validate_symbol(cls, v):\n        return v.upper()\n\nclass StockRequestResponse(BaseModel):\n    \"\"\"Stock tracking response model.\"\"\"\n    id: int\n    symbol: str\n    is_active: bool\n    last_pull_date: Optional[datetime] = None\n\n    class Config:\n        from_attributes = True\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform Pydantic model structure with proper validation and configuration.\n\nPydantic models must include proper field validation, descriptions, and ORM compatibility.\n\n### Error Response Models\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom pydantic import BaseModel\nfrom typing import Optional, Any\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response model.\"\"\"\n    detail: str\n    error_code: Optional[str] = None\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n\nclass ValidationErrorResponse(BaseModel):\n    \"\"\"Validation error response model.\"\"\"\n    detail: list[dict[str, Any]]\n    error_code: str = \"VALIDATION_ERROR\"\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform error response model structure for consistent error handling.\n\nError response models must include proper error details and timestamps.\n\n## 5. Dependency Injection Patterns\n\n### Database Dependencies\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ..db import get_async_db\n\nasync def get_current_user(\n    db: AsyncSession = Depends(get_async_db),\n    token: str = Depends(oauth2_scheme)\n) -> User:\n    \"\"\"Get current authenticated user.\"\"\"\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        user_id: int = payload.get(\"sub\")\n        if user_id is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n    user = await get_user_by_id(db, user_id)\n    if user is None:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n    return user\n\nasync def require_admin(\n    current_user: User = Depends(get_current_user)\n) -> User:\n    \"\"\"Require admin privileges.\"\"\"\n    if not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"Admin privileges required\")\n    return current_user\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform dependency injection implementation for authentication and authorization.\n\nDependencies must include proper error handling and type hints.\n\n### Service Dependencies\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom typing import Annotated\n\n# Service dependency\nasync def get_stock_service(\n    db: AsyncSession = Depends(get_async_db)\n) -> StockService:\n    \"\"\"Get stock service instance.\"\"\"\n    return StockService(db)\n\n# Use in endpoints\n@router.get(\"/stocks/{symbol}\")\nasync def get_stock(\n    symbol: str,\n    stock_service: Annotated[StockService, Depends(get_stock_service)]\n) -> StockResponse:\n    \"\"\"Get stock data using service dependency.\"\"\"\n    return await stock_service.get_stock(symbol)\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform service dependency injection for business logic separation.\n\nService dependencies must include proper type hints and error handling.\n\n## 6. Middleware and Exception Handling\n\n### Custom Exception Handler\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom fastapi import Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(\n    request: Request,\n    exc: RequestValidationError\n) -> JSONResponse:\n    \"\"\"Handle validation errors.\"\"\"\n    return JSONResponse(\n        status_code=422,\n        content={\n            \"detail\": exc.errors(),\n            \"error_code\": \"VALIDATION_ERROR\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )\n\n@app.exception_handler(Exception)\nasync def general_exception_handler(\n    request: Request,\n    exc: Exception\n) -> JSONResponse:\n    \"\"\"Handle general exceptions.\"\"\"\n    logger.error(f\"Unhandled exception: {exc}\")\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"detail\": \"Internal server error\",\n            \"error_code\": \"INTERNAL_ERROR\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform exception handler implementation for consistent error responses.\n\nException handlers must include proper logging and consistent error response format.\n\n### Custom Middleware\n"
      },
      {
        "type": "code_reference",
        "text": "python\nimport time\nfrom fastapi import Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Logging middleware for request/response tracking.\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n\n        # Log request\n        logger.info(f\"Request: {request.method} {request.url}\")\n\n        response = await call_next(request)\n\n        # Log response\n        process_time = time.time() - start_time\n        logger.info(f\"Response: {response.status_code} - {process_time:.3f}s\")\n\n        return response\n\n# Add middleware to app\napp.add_middleware(LoggingMiddleware)\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis pattern will inform custom middleware implementation for logging and monitoring.\n\nMiddleware must include proper logging and performance tracking.\n\n## 7. Background Tasks Integration\n\n### Task Definition and Usage\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom fastapi import BackgroundTasks\nfrom typing import List\n\nasync def send_email_notification(user_id: int, message: str) -> None:\n    \"\"\"Send email notification (background task).\"\"\"\n    try:\n        # Email sending logic here\n        logger.info(f\"Email sent to user {user_id}: {message}\")\n    except Exception as e:\n        logger.error(f\"Failed to send email to user {user_id}: {e}\")\n\nasync def process_data_batch(data: List[dict]) -> None:\n    \"\"\"Process data batch (background task).\"\"\"\n    try:\n        for item in data:\n            await process_single_item(item)\n        logger.info(f\"Processed {len(data)} items\")\n    except Exception as e:\n        logger.error(f\"Failed to process data batch: {e}\")\n\n@router.post(\"/users/{user_id}/notify\")\nasync def notify_user(\n    user_id: int,\n    message: str,\n    background_tasks: BackgroundTasks\n) -> dict:\n    \"\"\"Send notification to user with background task.\"\"\"\n    background_tasks.add_task(send_email_notification, user_id, message)\n\n    return {\"message\": \"Notification scheduled\"}\n"
      }
    ],
    "raw_content": "# FastAPI Development Guide\n\n> This guide provides comprehensive patterns and best practices for FastAPI development. Use these patterns to build robust, scalable API endpoints.\n\n## AI Metadata\n\n**Template Version:** 2.1\n**AI Processing Level:** High\n**Required Context:** FastAPI framework, async programming, API design patterns\n**Validation Required:** Yes\n**Code Generation:** Supported\n\n**Dependencies:**\n- `../Core%20Principles.md` - Decision-making frameworks\n- `../project_context/Common%20Patterns.md` - Project patterns\n- `../project_context/Architecture%20Overview.md` - System architecture\n- `Python%20Style%20Guide.md` - Python implementation patterns\n- `Python%20Testing%20Guide.md` - Testing patterns\n\n**Validation Rules:**\n- All endpoints must include proper type hints and response models\n- Error handling must follow established project patterns\n- Async/await must be used for all I/O operations\n- Pydantic models must be used for request/response validation\n- Testing must include both success and error cases\n\n## Overview\n\n**Document Purpose:** FastAPI development standards and best practices for the CreamPie project\n**Scope:** All API endpoints, routing, testing, and configuration\n**Target Users:** AI assistants and developers building FastAPI applications\n**Last Updated:** Current\n\n**AI Context:** This guide provides the foundational FastAPI development patterns that must be followed for all API development in the project. It ensures consistency, performance, and maintainability across all API endpoints.\n\n## 1. Route Handlers\n\n### General Guidelines\n- Use async/await for route handlers\n- Include return type hints for all route handlers\n- Group related routes using FastAPI routers\n- Use descriptive route paths and HTTP methods\n- Document API endpoints with clear docstrings\n\nThese guidelines will inform all FastAPI endpoint implementation throughout the project.\n\nAll route handlers must follow these guidelines without exception.\n\n### Example Route Handler\n```python\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom typing import List\n\nfrom ..db import get_async_db\nfrom ..models import User\nfrom ..schemas import UserResponse, UserCreate\n\nrouter = APIRouter()\n\n@router.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    db: AsyncSession = Depends(get_async_db)\n) -> UserResponse:\n    \"\"\"Get a user by their ID.\n\n    Args:\n        user_id: The ID of the user to retrieve\n        db: Database session dependency\n\n    Returns:\n        UserResponse: The requested user's data\n\n    Raises:\n        HTTPException: If the user is not found\n    \"\"\"\n    try:\n        user = await get_user_by_id(db, user_id)\n        if not user:\n            raise HTTPException(status_code=404, detail=\"User not found\")\n        return UserResponse.from_orm(user)\n    except Exception as e:\n        logger.error(f\"Error retrieving user {user_id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n```\n\nThis pattern will inform route handler implementation with proper error handling and response models.\n\nRoute handlers must include proper error handling, logging, and response model validation.\n\n### Router Organization Pattern\n```python\n# In cream_api/stock_data/api.py\nfrom fastapi import APIRouter, Depends, HTTPException, BackgroundTasks\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ..db import get_async_db\nfrom ..models import TrackedStock\nfrom ..schemas import StockRequestCreate, StockRequestResponse\nfrom ..tasks import update_all_tracked_stocks\n\nrouter = APIRouter(prefix=\"/stock-data\", tags=[\"Stock Data\"])\n\n@router.post(\"/track\", response_model=StockRequestResponse)\nasync def track_stock(\n    request: StockRequestCreate,\n    background_tasks: BackgroundTasks,\n    db: AsyncSession = Depends(get_async_db)\n) -> StockRequestResponse:\n    \"\"\"Add a new stock to tracking.\"\"\"\n    try:\n        # Business logic here\n        tracked_stock = await create_tracked_stock(db, request.symbol)\n\n        # Add background task\n        background_tasks.add_task(update_all_tracked_stocks)\n\n        return StockRequestResponse.from_orm(tracked_stock)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        logger.error(f\"Error tracking stock {request.symbol}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n```\n\nThis pattern will inform router organization and endpoint implementation with background tasks.\n\nRouters must include proper prefixes, tags, error handling, and background task integration.\n\n## 2. Configuration\n\n### Settings Management\n- Use Pydantic for settings management\n- Implement settings as a class inheriting from BaseSettings\n- Use environment variables for configuration\n- Cache configuration using lru_cache decorator\n- Keep configuration logic separate from application code\n\nThese patterns will inform configuration management throughout the project.\n\nConfiguration must use Pydantic models and environment variable support.\n\n### Example Settings Class\n```python\nfrom pydantic_settings import BaseSettings\nfrom functools import lru_cache\nfrom typing import Optional\n\nclass AppSettings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n\n    # Database settings\n    DATABASE_URL: str\n    DATABASE_ECHO: bool = False\n\n    # API settings\n    API_V1_STR: str = \"/api/v1\"\n    PROJECT_NAME: str = \"Cream API\"\n    VERSION: str = \"1.0.0\"\n\n    # Security settings\n    SECRET_KEY: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    ALGORITHM: str = \"HS256\"\n\n    # CORS settings\n    BACKEND_CORS_ORIGINS: list[str] = [\"http://localhost:3000\"]\n\n    # Logging settings\n    LOG_LEVEL: str = \"INFO\"\n\n    class Config:\n        env_file = \".env\"\n        case_sensitive = True\n\n@lru_cache()\ndef get_settings() -> AppSettings:\n    \"\"\"Get cached application settings.\"\"\"\n    return AppSettings()\n```\n\nThis pattern will inform settings class structure with comprehensive configuration options.\n\nSettings must include all necessary configuration options and proper environment variable support.\n\n### Application Configuration\n```python\n# In cream_api/main.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom contextlib import asynccontextmanager\n\nfrom .settings import get_settings\nfrom .db import init_db\n\nsettings = get_settings()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan manager.\"\"\"\n    # Startup\n    await init_db()\n    yield\n    # Shutdown\n    # Cleanup code here\n\napp = FastAPI(\n    title=settings.PROJECT_NAME,\n    version=settings.VERSION,\n    lifespan=lifespan\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.BACKEND_CORS_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n```\n\nThis pattern will inform FastAPI application configuration with proper middleware and lifespan management.\n\nApplication configuration must include proper middleware, lifespan management, and CORS settings.\n\n## 3. Testing FastAPI Applications\n\n### Test Application Setup\n```python\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom ..main import app\nfrom ..db import get_async_db\nfrom ..models import Base\n\n# Test database\nTEST_DATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(TEST_DATABASE_URL, echo=False)\nTestingSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n@pytest.fixture\nasync def async_test_db():\n    \"\"\"Create test database session.\"\"\"\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with TestingSessionLocal() as session:\n        yield session\n\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n\n@pytest.fixture\ndef test_app(async_test_db: AsyncSession):\n    \"\"\"Create a test FastAPI application.\"\"\"\n    async def override_get_async_db():\n        yield async_test_db\n\n    app.dependency_overrides[get_async_db] = override_get_async_db\n    return app\n\n@pytest.fixture\ndef client(test_app):\n    \"\"\"Create test client.\"\"\"\n    return TestClient(test_app)\n```\n\nThis pattern will inform FastAPI testing setup with proper database fixtures and dependency overrides.\n\nTest setup must include proper database fixtures, dependency overrides, and test client creation.\n\n### Endpoint Testing\n```python\nimport pytest\nfrom httpx import AsyncClient\n\n@pytest.mark.asyncio\nasync def test_get_user_success(client: TestClient, async_test_db: AsyncSession):\n    \"\"\"Test successful user retrieval.\"\"\"\n    # Setup test data\n    user = User(email=\"test@example.com\", username=\"testuser\")\n    async_test_db.add(user)\n    await async_test_db.commit()\n\n    # Test endpoint\n    response = client.get(f\"/users/{user.id}\")\n\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"email\"] == \"test@example.com\"\n    assert data[\"username\"] == \"testuser\"\n\n@pytest.mark.asyncio\nasync def test_get_user_not_found(client: TestClient):\n    \"\"\"Test user not found error.\"\"\"\n    response = client.get(\"/users/999\")\n\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n@pytest.mark.asyncio\nasync def test_create_user_success(client: TestClient):\n    \"\"\"Test successful user creation.\"\"\"\n    user_data = {\n        \"email\": \"new@example.com\",\n        \"username\": \"newuser\",\n        \"password\": \"securepassword\"\n    }\n\n    response = client.post(\"/users/\", json=user_data)\n\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"email\"] == user_data[\"email\"]\n    assert data[\"username\"] == user_data[\"username\"]\n```\n\nThis pattern will inform endpoint testing with comprehensive success and error case coverage.\n\nEndpoint tests must include both success and error cases with proper assertions.\n\n### Background Task Testing\n```python\nfrom unittest.mock import patch\n\n@pytest.mark.asyncio\nasync def test_track_stock_with_background_task(client: TestClient):\n    \"\"\"Test stock tracking with background task.\"\"\"\n    with patch('cream_api.stock_data.api.update_all_tracked_stocks') as mock_task:\n        response = client.post(\"/stock-data/track\", json={\"symbol\": \"AAPL\"})\n\n        assert response.status_code == 200\n        mock_task.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_background_task_error_handling(client: TestClient):\n    \"\"\"Test background task error handling.\"\"\"\n    with patch('cream_api.stock_data.api.update_all_tracked_stocks') as mock_task:\n        mock_task.side_effect = Exception(\"Task failed\")\n\n        response = client.post(\"/stock-data/track\", json={\"symbol\": \"AAPL\"})\n\n        # Should still succeed even if background task fails\n        assert response.status_code == 200\n```\n\nThis pattern will inform background task testing with proper mocking and error handling.\n\nBackground task tests must include proper mocking and error handling scenarios.\n\n## 4. Pydantic Schema Patterns\n\n### Request/Response Models\n```python\nfrom pydantic import BaseModel, Field, validator\nfrom datetime import datetime\nfrom typing import Optional\n\nclass UserBase(BaseModel):\n    \"\"\"Base user model.\"\"\"\n    email: str = Field(..., description=\"User email address\")\n    username: str = Field(..., min_length=3, max_length=50, description=\"Username\")\n\nclass UserCreate(UserBase):\n    \"\"\"User creation model.\"\"\"\n    password: str = Field(..., min_length=8, description=\"User password\")\n\n    @validator('email')\n    def validate_email(cls, v):\n        if '@' not in v:\n            raise ValueError('Invalid email format')\n        return v.lower()\n\nclass UserResponse(UserBase):\n    \"\"\"User response model.\"\"\"\n    id: int\n    created_at: datetime\n    is_active: bool = True\n\n    class Config:\n        from_attributes = True\n\nclass StockRequestCreate(BaseModel):\n    \"\"\"Stock tracking request model.\"\"\"\n    symbol: str = Field(..., min_length=1, max_length=10, regex=r'^[A-Z]+$')\n\n    @validator('symbol')\n    def validate_symbol(cls, v):\n        return v.upper()\n\nclass StockRequestResponse(BaseModel):\n    \"\"\"Stock tracking response model.\"\"\"\n    id: int\n    symbol: str\n    is_active: bool\n    last_pull_date: Optional[datetime] = None\n\n    class Config:\n        from_attributes = True\n```\n\nThis pattern will inform Pydantic model structure with proper validation and configuration.\n\nPydantic models must include proper field validation, descriptions, and ORM compatibility.\n\n### Error Response Models\n```python\nfrom pydantic import BaseModel\nfrom typing import Optional, Any\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response model.\"\"\"\n    detail: str\n    error_code: Optional[str] = None\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n\nclass ValidationErrorResponse(BaseModel):\n    \"\"\"Validation error response model.\"\"\"\n    detail: list[dict[str, Any]]\n    error_code: str = \"VALIDATION_ERROR\"\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n```\n\nThis pattern will inform error response model structure for consistent error handling.\n\nError response models must include proper error details and timestamps.\n\n## 5. Dependency Injection Patterns\n\n### Database Dependencies\n```python\nfrom fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ..db import get_async_db\n\nasync def get_current_user(\n    db: AsyncSession = Depends(get_async_db),\n    token: str = Depends(oauth2_scheme)\n) -> User:\n    \"\"\"Get current authenticated user.\"\"\"\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        user_id: int = payload.get(\"sub\")\n        if user_id is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n    user = await get_user_by_id(db, user_id)\n    if user is None:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n    return user\n\nasync def require_admin(\n    current_user: User = Depends(get_current_user)\n) -> User:\n    \"\"\"Require admin privileges.\"\"\"\n    if not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"Admin privileges required\")\n    return current_user\n```\n\nThis pattern will inform dependency injection implementation for authentication and authorization.\n\nDependencies must include proper error handling and type hints.\n\n### Service Dependencies\n```python\nfrom typing import Annotated\n\n# Service dependency\nasync def get_stock_service(\n    db: AsyncSession = Depends(get_async_db)\n) -> StockService:\n    \"\"\"Get stock service instance.\"\"\"\n    return StockService(db)\n\n# Use in endpoints\n@router.get(\"/stocks/{symbol}\")\nasync def get_stock(\n    symbol: str,\n    stock_service: Annotated[StockService, Depends(get_stock_service)]\n) -> StockResponse:\n    \"\"\"Get stock data using service dependency.\"\"\"\n    return await stock_service.get_stock(symbol)\n```\n\nThis pattern will inform service dependency injection for business logic separation.\n\nService dependencies must include proper type hints and error handling.\n\n## 6. Middleware and Exception Handling\n\n### Custom Exception Handler\n```python\nfrom fastapi import Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(\n    request: Request,\n    exc: RequestValidationError\n) -> JSONResponse:\n    \"\"\"Handle validation errors.\"\"\"\n    return JSONResponse(\n        status_code=422,\n        content={\n            \"detail\": exc.errors(),\n            \"error_code\": \"VALIDATION_ERROR\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )\n\n@app.exception_handler(Exception)\nasync def general_exception_handler(\n    request: Request,\n    exc: Exception\n) -> JSONResponse:\n    \"\"\"Handle general exceptions.\"\"\"\n    logger.error(f\"Unhandled exception: {exc}\")\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"detail\": \"Internal server error\",\n            \"error_code\": \"INTERNAL_ERROR\",\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n    )\n```\n\nThis pattern will inform exception handler implementation for consistent error responses.\n\nException handlers must include proper logging and consistent error response format.\n\n### Custom Middleware\n```python\nimport time\nfrom fastapi import Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Logging middleware for request/response tracking.\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n\n        # Log request\n        logger.info(f\"Request: {request.method} {request.url}\")\n\n        response = await call_next(request)\n\n        # Log response\n        process_time = time.time() - start_time\n        logger.info(f\"Response: {response.status_code} - {process_time:.3f}s\")\n\n        return response\n\n# Add middleware to app\napp.add_middleware(LoggingMiddleware)\n```\n\nThis pattern will inform custom middleware implementation for logging and monitoring.\n\nMiddleware must include proper logging and performance tracking.\n\n## 7. Background Tasks Integration\n\n### Task Definition and Usage\n```python\nfrom fastapi import BackgroundTasks\nfrom typing import List\n\nasync def send_email_notification(user_id: int, message: str) -> None:\n    \"\"\"Send email notification (background task).\"\"\"\n    try:\n        # Email sending logic here\n        logger.info(f\"Email sent to user {user_id}: {message}\")\n    except Exception as e:\n        logger.error(f\"Failed to send email to user {user_id}: {e}\")\n\nasync def process_data_batch(data: List[dict]) -> None:\n    \"\"\"Process data batch (background task).\"\"\"\n    try:\n        for item in data:\n            await process_single_item(item)\n        logger.info(f\"Processed {len(data)} items\")\n    except Exception as e:\n        logger.error(f\"Failed to process data batch: {e}\")\n\n@router.post(\"/users/{user_id}/notify\")\nasync def notify_user(\n    user_id: int,\n    message: str,\n    background_tasks: BackgroundTasks\n) -> dict:\n    \"\"\"Send notification to user with background task.\"\"\"\n    background_tasks.add_task(send_email_notification, user_id, message)\n\n    return {\"message\": \"Notification scheduled\"}\n```\n\nThis pattern will inform background task implementation and usage in endpoints.\n\nBackground tasks must include proper error handling and logging.\n\n## Implementation Guidelines\n\n### For AI Assistants\n1. **Follow this guide** for all FastAPI development\n2. **Use async/await** for all route handlers\n3. **Include type hints** for all functions and parameters\n4. **Use Pydantic models** for request/response validation\n5. **Implement proper error handling** with custom exceptions\n6. **Write comprehensive tests** for all endpoints\n7. **Use dependency injection** for service separation\n8. **Include background tasks** for long-running operations\n\n### For Human Developers\n1. **Reference this guide** when building FastAPI applications\n2. **Use async/await** for better performance\n3. **Write comprehensive tests** for all endpoints\n4. **Follow established patterns** for consistency\n5. **Use Pydantic models** for data validation\n6. **Implement proper error handling** and logging\n7. **Use dependency injection** for maintainability\n\n## Quality Assurance\n\n### API Quality Standards\n- All endpoints must include proper type hints and response models\n- Error handling must be comprehensive and consistent\n- Async/await must be used for all I/O operations\n- Pydantic models must be used for validation\n- Background tasks must include proper error handling\n\n### Testing Requirements\n- All endpoints must have unit tests\n- Tests must cover both success and error cases\n- Background tasks must be tested with proper mocking\n- Integration tests must include database operations\n\n### Documentation Standards\n- All endpoints must include comprehensive docstrings\n- API documentation must be generated with OpenAPI\n- Examples must be provided for all endpoints\n- Error responses must be documented\n\n### Performance Considerations\n- Use async/await for all I/O operations\n- Implement proper caching strategies\n- Use background tasks for long-running operations\n- Monitor API performance and response times\n\n---\n\n**AI Quality Checklist**: Before implementing FastAPI endpoints, ensure:\n- [x] Async/await is used for all route handlers\n- [x] Type hints are included for all functions and parameters\n- [x] Pydantic models are used for request/response validation\n- [x] Error handling is comprehensive and consistent\n- [x] Background tasks are used for long-running operations\n- [x] Tests are written for all endpoints\n- [x] Documentation is comprehensive and accurate\n- [x] Performance considerations are addressed\n"
  },
  "cross_references": [],
  "code_generation_hints": [
    {
      "context": "general",
      "hint": "These guidelines will inform all FastAPI endpoint implementation throughout the project.",
      "validation": ""
    },
    {
      "context": "error handling",
      "hint": "This pattern will inform route handler implementation with proper error handling and response models.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This pattern will inform router organization and endpoint implementation with background tasks.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "These patterns will inform configuration management throughout the project.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This pattern will inform settings class structure with comprehensive configuration options.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This pattern will inform FastAPI application configuration with proper middleware and lifespan management.",
      "validation": ""
    },
    {
      "context": "testing",
      "hint": "This pattern will inform FastAPI testing setup with proper database fixtures and dependency overrides.",
      "validation": ""
    },
    {
      "context": "error handling",
      "hint": "This pattern will inform endpoint testing with comprehensive success and error case coverage.",
      "validation": ""
    },
    {
      "context": "error handling",
      "hint": "This pattern will inform background task testing with proper mocking and error handling.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This pattern will inform Pydantic model structure with proper validation and configuration.",
      "validation": ""
    },
    {
      "context": "error handling",
      "hint": "This pattern will inform error response model structure for consistent error handling.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This pattern will inform dependency injection implementation for authentication and authorization.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This pattern will inform service dependency injection for business logic separation.",
      "validation": ""
    },
    {
      "context": "error handling",
      "hint": "This pattern will inform exception handler implementation for consistent error responses.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This pattern will inform custom middleware implementation for logging and monitoring.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This pattern will inform background task implementation and usage in endpoints.",
      "validation": ""
    }
  ],
  "validation_rules": [
    "Application configuration must include proper middleware, lifespan management, and CORS settings",
    "Endpoint tests must include both success and error cases with proper assertions",
    "> User:\n    \"\"\"Require admin privileges.\"\"\"\n    if not current_user.is_admin:\n        raise HTTPException(status_code=403, detail=\"Admin privileges required\")\n    return current_user\n```",
    "Background tasks must be tested with proper mocking",
    "Error response models must include proper error details and timestamps",
    "Pydantic models must be used for validation",
    "Middleware must include proper logging and performance tracking",
    "Settings must include all necessary configuration options and proper environment variable support",
    "Background tasks must include proper error handling and logging",
    "Dependencies must include proper error handling and type hints",
    "Integration tests must include database operations",
    "Service dependencies must include proper type hints and error handling",
    "Exception handlers must include proper logging and consistent error response format",
    "Examples must be provided for all endpoints",
    "Pydantic models must be used for request/response validation",
    "All endpoints must have unit tests",
    "Tests must cover both success and error cases",
    "Error handling must be comprehensive and consistent",
    "All endpoints must include comprehensive docstrings",
    "Testing must include both success and error cases",
    "All endpoints must include proper type hints and response models",
    "Error responses must be documented",
    "All route handlers must follow these guidelines without exception",
    "Async/await must be used for all I/O operations",
    "Route handlers must include proper error handling, logging, and response model validation",
    "Test setup must include proper database fixtures, dependency overrides, and test client creation",
    "Background tasks must include proper error handling",
    "API documentation must be generated with OpenAPI",
    "Error handling must follow established project patterns",
    "Background task tests must include proper mocking and error handling scenarios",
    "Pydantic models must include proper field validation, descriptions, and ORM compatibility",
    "Configuration must use Pydantic models and environment variable support",
    "Routers must include proper prefixes, tags, error handling, and background task integration"
  ],
  "optimization": {
    "version": "1.0",
    "optimized_at": "2025-06-18T19:19:47.740928",
    "improvements": [
      "fixed_file_references",
      "extracted_ai_metadata",
      "structured_cross_references",
      "extracted_code_hints",
      "structured_validation_rules"
    ],
    "literal_strings_cleaned": true,
    "cleaned_at": "2025-06-18T19:30:00.000000"
  }
}