{
  "ai_metadata": {
    "purpose": "",
    "last_updated": "",
    "template_version": "2.1",
    "ai_tool_compatibility": "",
    "ai_processing_level": "High",
    "required_context": "React, TypeScript, Tailwind CSS, modern frontend development",
    "validation_required": "Yes",
    "code_generation": "Supported",
    "cross_references": [
      "../Core%20Principles.json",
      "../Language-Specific/Python%20Testing%20Guide.json",
      "../../project_context/Architecture%20Overview.json",
      "../../project_context/Common%20Patterns.json"
    ],
    "maintenance": ""
  },
  "file_info": {
    "file_path": "guide_docs/Domain-Specific/Frontend Style Guide.md",
    "original_format": "markdown",
    "converted_at": "2025-06-18T19:14:30.262890",
    "file_size": 27146,
    "line_count": 1019,
    "optimized_at": "2025-06-18T19:19:47.749066",
    "optimization_version": "1.0"
  },
  "content": {
    "sections": [
      {
        "level": 1,
        "title": "Frontend Style Guide",
        "content": "> This guide provides comprehensive patterns and best practices for frontend development. Use these patterns to create consistent, maintainable user interfaces.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "AI Metadata",
        "content": "**Template Version:** 2.1\n**AI Processing Level:** High\n**Required Context:** React, TypeScript, Tailwind CSS, modern frontend development\n**Validation Required:** Yes\n**Code Generation:** Supported\n\n**Dependencies:**\n- `../Core%20Principles.json.replace(\".json\", \".json\")` - Decision-making frameworks\n- `../Language-Specific/Python%20Testing%20Guide.json.replace(\".json\", \".json\")` - Testing patterns\n- `../../project_context/Architecture%20Overview.json.replace(\".json\", \".json\")` - System architecture\n- `../../project_context/Common%20Patterns.json.replace(\".json\", \".json\")` - Project-specific patterns\n\n**Validation Rules:**\n- All components must use TypeScript with proper type definitions\n- Components must follow single responsibility principle\n- State management must use appropriate React patterns\n- Styling must use Tailwind CSS with proper organization\n- All components must include proper error handling and loading states",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Overview",
        "content": "**Document Purpose:** React/TypeScript development standards and best practices for the CreamPie project\n**Scope:** Component development, state management, styling, testing, and performance optimization\n**Target Users:** AI assistants and developers building React applications\n**Last Updated:** Current\n\n**AI Context:** This guide provides the foundational React patterns that must be followed for all frontend development in the project. It ensures maintainable, performant, and accessible React applications.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "1. Component Structure",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "File Organization",
        "content": "- Place components in the `src/components` directory\n- Place pages in the `src/pages` directory\n- Use PascalCase for component file names (e.g., `Navbar.tsx`, `LandingPage.tsx`)\n\nThis organization will inform all component file placement and naming conventions.\n\nAll components must follow this file organization structure.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Component Naming",
        "content": "- Use PascalCase for component names\n- Use descriptive names that indicate the component's purpose\n- Prefix page components with the page name (e.g., `LandingPage`)\n\nThis naming convention will inform all component naming decisions.\n\nAll component names must follow PascalCase and be descriptive.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Component Structure Patterns",
        "content": "```tsx\nimport React, { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { OtherComponent } from \"../components/OtherComponent\";\n\ninterface ComponentNameProps {\n  title: string;\n  isActive?: boolean;\n  onAction?: (value: string) => void;\n}\n\nexport function ComponentName({ title, isActive = false, onAction }: ComponentNameProps) {\n  const [localState, setLocalState] = useState<string>(\"\");\n\n  useEffect(() => {\n    // Component initialization logic\n    console.log(\"Component mounted\");\n\n    return () => {\n      // Cleanup logic\n      console.log(\"Component unmounted\");\n    };\n  }, []);\n\n  const handleClick = () => {\n    if (onAction) {\n      onAction(localState);\n    }\n  };\n\n  return (\n    <div className=\"\n      // Layout\n      flex items-center justify-between\n\n      // Box model\n      p-4 m-2\n\n      // Visual\n      bg-white shadow-sm rounded-lg\n\n      // Typography\n      text-gray-900\n\n      // Transitions\n      transition-colors duration-200\n\n      // Conditional styling\n      hover:bg-gray-50\n      ${isActive ? 'border-blue-500' : 'border-gray-200'}\n    \">\n      <h2 className=\"text-xl font-semibold\">{title}</h2>\n      <button\n        onClick={handleClick}\n        className=\"\n          px-4 py-2\n          bg-blue-500 text-white\n          rounded-md\n          hover:bg-blue-600\n          transition-colors duration-200\n        \"\n      >\n        Action\n      </button>\n    </div>\n  );\n}\n```\n\nThis component pattern will inform all React component implementation with proper TypeScript and styling.\n\nAll components must include proper TypeScript interfaces, error handling, and Tailwind CSS organization.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Import Considerations",
        "content": "- @import must precede all other statements (besides @charset or empty @layer)\n- The first import should always be `import * as React from \"react\";`, if needed.\n- `// @ts-expect-error - React is needed for JSX` should always be above it.\n\nThis import pattern will inform all component import organization.\n\nAll imports must follow this organization pattern.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "2. TypeScript Patterns",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Type Definitions",
        "content": "```tsx\n// Common type definitions\nexport interface User {\n  id: number;\n  email: string;\n  username: string;\n  isActive: boolean;\n  createdAt: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  message?: string;\n  error?: string;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  perPage: number;\n  totalPages: number;\n}\n\n// Component prop types\nexport interface ButtonProps {\n  children: React.ReactNode;\n  variant?: 'primary' | 'secondary' | 'danger';\n  size?: 'sm' | 'md' | 'lg';\n  disabled?: boolean;\n  loading?: boolean;\n  onClick?: () => void;\n  className?: string;\n}\n\n// Form types\nexport interface FormData {\n  email: string;\n  password: string;\n  rememberMe?: boolean;\n}\n\nexport interface FormErrors {\n  email?: string;\n  password?: string;\n  general?: string;\n}\n```\n\nThis type pattern will inform all TypeScript type definition implementation.\n\nAll components must include proper TypeScript interfaces and type definitions.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Hook Patterns",
        "content": "```tsx\nimport { useState, useEffect, useCallback, useMemo } from 'react';\n\n// Custom hook for API calls\nexport function useApiCall<T>(\n  apiFunction: () => Promise<T>,\n  dependencies: React.DependencyList = []\n) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchData = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const result = await apiFunction();\n      setData(result);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'An error occurred');\n    } finally {\n      setLoading(false);\n    }\n  }, dependencies);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return { data, loading, error, refetch: fetchData };\n}\n\n// Custom hook for form management\nexport function useForm<T extends Record<string, any>>(initialValues: T) {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});\n\n  const handleChange = useCallback((name: keyof T, value: any) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    // Clear error when user starts typing\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: undefined }));\n    }\n  }, [errors]);\n\n  const handleSubmit = useCallback((onSubmit: (values: T) => void) => {\n    return (e: React.FormEvent) => {\n      e.preventDefault();\n      onSubmit(values);\n    };\n  }, [values]);\n\n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n  }, [initialValues]);\n\n  return {\n    values,\n    errors,\n    handleChange,\n    handleSubmit,\n    reset,\n    setErrors\n  };\n}\n```\n\nThis hook pattern will inform all custom hook implementation with proper TypeScript and error handling.\n\nAll custom hooks must include proper TypeScript types and error handling.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "3. State Management",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Component State",
        "content": "```tsx\nimport React, { useState, useReducer, useCallback } from 'react';\n\n// Simple state management\nexport function SimpleStateComponent() {\n  const [count, setCount] = useState<number>(0);\n  const [isVisible, setIsVisible] = useState<boolean>(true);\n\n  const increment = useCallback(() => {\n    setCount(prev => prev + 1);\n  }, []);\n\n  const toggleVisibility = useCallback(() => {\n    setIsVisible(prev => !prev);\n  }, []);\n\n  return (\n    <div className=\"p-4\">\n      {isVisible && (\n        <div className=\"text-center\">\n          <h2 className=\"text-2xl font-bold\">Count: {count}</h2>\n          <button\n            onClick={increment}\n            className=\"mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n          >\n            Increment\n          </button>\n        </div>\n      )}\n      <button\n        onClick={toggleVisibility}\n        className=\"mt-4 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600\"\n      >\n        {isVisible ? 'Hide' : 'Show'}\n      </button>\n    </div>\n  );\n}\n\n// Complex state management with useReducer\ninterface TodoState {\n  todos: Todo[];\n  filter: 'all' | 'active' | 'completed';\n  loading: boolean;\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ntype TodoAction =\n  | { type: 'ADD_TODO'; payload: string }\n  | { type: 'TOGGLE_TODO'; payload: number }\n  | { type: 'SET_FILTER'; payload: 'all' | 'active' | 'completed' }\n  | { type: 'SET_LOADING'; payload: boolean };\n\nfunction todoReducer(state: TodoState, action: TodoAction): TodoState {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        ...state,\n        todos: [...state.todos, {\n          id: Date.now(),\n          text: action.payload,\n          completed: false\n        }]\n      };\n    case 'TOGGLE_TODO':\n      return {\n        ...state,\n        todos: state.todos.map(todo =>\n          todo.id === action.payload\n            ? { ...todo, completed: !todo.completed }\n            : todo\n        )\n      };\n    case 'SET_FILTER':\n      return { ...state, filter: action.payload };\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    default:\n      return state;\n  }\n}\n\nexport function TodoList() {\n  const [state, dispatch] = useReducer(todoReducer, {\n    todos: [],\n    filter: 'all',\n    loading: false\n  });\n  const [newTodo, setNewTodo] = useState<string>('');\n\n  const addTodo = useCallback(() => {\n    if (newTodo.trim()) {\n      dispatch({ type: 'ADD_TODO', payload: newTodo.trim() });\n      setNewTodo('');\n    }\n  }, [newTodo]);\n\n  const filteredTodos = useMemo(() => {\n    switch (state.filter) {\n      case 'active':\n        return state.todos.filter(todo => !todo.completed);\n      case 'completed':\n        return state.todos.filter(todo => todo.completed);\n      default:\n        return state.todos;\n    }\n  }, [state.todos, state.filter]);\n\n  return (\n    <div className=\"max-w-md mx-auto p-4\">\n      <h1 className=\"text-2xl font-bold mb-4\">Todo List</h1>\n\n      <div className=\"flex gap-2 mb-4\">\n        <input\n          type=\"text\"\n          value={newTodo}\n          onChange={(e) => setNewTodo(e.target.value)}\n          onKeyPress={(e) => e.key === 'Enter' && addTodo()}\n          placeholder=\"Add new todo...\"\n          className=\"flex-1 px-3 py-2 border rounded\"\n        />\n        <button\n          onClick={addTodo}\n          className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n        >\n          Add\n        </button>\n      </div>\n\n      <div className=\"flex gap-2 mb-4\">\n        {(['all', 'active', 'completed'] as const).map(filter => (\n          <button\n            key={filter}\n            onClick={() => dispatch({ type: 'SET_FILTER', payload: filter })}\n            className={`px-3 py-1 rounded ${\n              state.filter === filter\n                ? 'bg-blue-500 text-white'\n                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'\n            }`}\n          >\n            {filter.charAt(0).toUpperCase() + filter.slice(1)}\n          </button>\n        ))}\n      </div>\n\n      <ul className=\"space-y-2\">\n        {filteredTodos.map(todo => (\n          <li\n            key={todo.id}\n            className=\"flex items-center gap-2 p-2 border rounded\"\n          >\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}\n              className=\"rounded\"\n            />\n            <span className={todo.completed ? 'line-through text-gray-500' : ''}>\n              {todo.text}\n            </span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\nThis state management pattern will inform all React state implementation with proper TypeScript and performance optimization.\n\nAll state management must use appropriate React patterns and include proper TypeScript types.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "4. Styling with Tailwind CSS",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Class Organization",
        "content": "- Group related classes together\n- Use consistent spacing between class groups\n- Follow this order:\n  1. Layout (display, position, etc.)\n  2. Box model (margin, padding, etc.)\n  3. Visual (colors, backgrounds, etc.)\n  4. Typography\n  5. Transitions/Animations\n\nThis class organization will inform all Tailwind CSS implementation.\n\nAll Tailwind classes must follow this organization pattern.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Component Styling Patterns",
        "content": "```tsx\n// Reusable style components\nconst buttonVariants = {\n  primary: \"bg-blue-500 text-white hover:bg-blue-600 focus:ring-blue-500\",\n  secondary: \"bg-gray-500 text-white hover:bg-gray-600 focus:ring-gray-500\",\n  danger: \"bg-red-500 text-white hover:bg-red-600 focus:ring-red-500\",\n  outline: \"border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-gray-500\"\n};\n\nconst buttonSizes = {\n  sm: \"px-3 py-1.5 text-sm\",\n  md: \"px-4 py-2 text-base\",\n  lg: \"px-6 py-3 text-lg\"\n};\n\ninterface ButtonProps {\n  children: React.ReactNode;\n  variant?: keyof typeof buttonVariants;\n  size?: keyof typeof buttonSizes;\n  disabled?: boolean;\n  loading?: boolean;\n  onClick?: () => void;\n  className?: string;\n}\n\nexport function Button({\n  children,\n  variant = 'primary',\n  size = 'md',\n  disabled = false,\n  loading = false,\n  onClick,\n  className = ''\n}: ButtonProps) {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled || loading}\n      className={`\n        // Layout\n        inline-flex items-center justify-center\n\n        // Box model\n        ${buttonSizes[size]}\n\n        // Visual\n        ${buttonVariants[variant]}\n        rounded-md font-medium\n\n        // Typography\n        font-medium\n\n        // Transitions\n        transition-colors duration-200\n\n        // States\n        focus:outline-none focus:ring-2 focus:ring-offset-2\n        disabled:opacity-50 disabled:cursor-not-allowed\n\n        // Custom classes\n        ${className}\n      `}\n    >\n      {loading && (\n        <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\">\n          <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\n          <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\n        </svg>\n      )}\n      {children}\n    </button>\n  );\n}\n```\n\nThis styling pattern will inform all component styling implementation with reusable variants.\n\nAll component styling must use consistent patterns and include proper state handling.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Responsive Design",
        "content": "```tsx\n// Responsive component example\nexport function ResponsiveCard() {\n  return (\n    <div className=\"\n      // Layout - responsive grid\n      grid grid-cols-1\n      sm:grid-cols-2\n      lg:grid-cols-3\n      xl:grid-cols-4\n\n      // Box model - responsive spacing\n      gap-4\n      p-4\n      sm:p-6\n      lg:p-8\n\n      // Visual\n      bg-white shadow-lg rounded-lg\n\n      // Typography - responsive text sizes\n      text-sm\n      sm:text-base\n      lg:text-lg\n    \">\n      <div className=\"\n        // Layout\n        flex flex-col\n\n        // Box model\n        p-4\n        sm:p-6\n\n        // Visual\n        bg-gray-50 rounded-lg\n\n        // Typography\n        text-center\n      \">\n        <h3 className=\"\n          text-lg\n          sm:text-xl\n          lg:text-2xl\n          font-bold\n          text-gray-900\n          mb-2\n        \">\n          Card Title\n        </h3>\n        <p className=\"\n          text-sm\n          sm:text-base\n          text-gray-600\n        \">\n          Responsive content that adapts to different screen sizes\n        </p>\n      </div>\n    </div>\n  );\n}\n```\n\nThis responsive pattern will inform all responsive design implementation.\n\nAll responsive components must use mobile-first design principles.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "5. Form Handling",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Form Components",
        "content": "```tsx\nimport React, { useState } from 'react';\n\ninterface FormFieldProps {\n  label: string;\n  name: string;\n  type?: 'text' | 'email' | 'password' | 'number';\n  value: string;\n  onChange: (name: string, value: string) => void;\n  error?: string;\n  required?: boolean;\n  placeholder?: string;\n}\n\nexport function FormField({\n  label,\n  name,\n  type = 'text',\n  value,\n  onChange,\n  error,\n  required = false,\n  placeholder\n}: FormFieldProps) {\n  return (\n    <div className=\"mb-4\">\n      <label htmlFor={name} className=\"\n        block\n        text-sm\n        font-medium\n        text-gray-700\n        mb-1\n      \">\n        {label}\n        {required && <span className=\"text-red-500 ml-1\">*</span>}\n      </label>\n      <input\n        id={name}\n        type={type}\n        value={value}\n        onChange={(e) => onChange(name, e.target.value)}\n        placeholder={placeholder}\n        className={`\n          // Layout\n          block w-full\n\n          // Box model\n          px-3 py-2\n\n          // Visual\n          border rounded-md\n          ${error ? 'border-red-500' : 'border-gray-300'}\n          focus:outline-none focus:ring-2\n          ${error ? 'focus:ring-red-500' : 'focus:ring-blue-500'}\n          focus:border-transparent\n\n          // Typography\n          text-sm\n\n          // Transitions\n          transition-colors duration-200\n        `}\n      />\n      {error && (\n        <p className=\"mt-1 text-sm text-red-600\">{error}</p>\n      )}\n    </div>\n  );\n}\n\n// Form validation\nexport function useFormValidation<T extends Record<string, any>>(\n  initialValues: T,\n  validationRules: Record<keyof T, (value: any) => string | undefined>\n) {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});\n\n  const validate = (name: keyof T, value: any): string | undefined => {\n    const rule = validationRules[name];\n    return rule ? rule(value) : undefined;\n  };\n\n  const handleChange = (name: keyof T, value: any) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    const error = validate(name, value);\n    setErrors(prev => ({ ...prev, [name]: error }));\n  };\n\n  const validateAll = (): boolean => {\n    const newErrors: Partial<Record<keyof T, string>> = {};\n    let isValid = true;\n\n    Object.keys(validationRules).forEach(key => {\n      const name = key as keyof T;\n      const error = validate(name, values[name]);\n      if (error) {\n        newErrors[name] = error;\n        isValid = false;\n      }\n    });\n\n    setErrors(newErrors);\n    return isValid;\n  };\n\n  return {\n    values,\n    errors,\n    handleChange,\n    validateAll,\n    setValues\n  };\n}\n\n// Usage example\nexport function LoginForm() {\n  const validationRules = {\n    email: (value: string) => {\n      if (!value) return 'Email is required';\n      if (!/\\S+@\\S+\\.\\S+/.test(value)) return 'Email is invalid';\n      return undefined;\n    },\n    password: (value: string) => {\n      if (!value) return 'Password is required';\n      if (value.length < 6) return 'Password must be at least 6 characters';\n      return undefined;\n    }\n  };\n\n  const { values, errors, handleChange, validateAll } = useFormValidation(\n    { email: '', password: '' },\n    validationRules\n  );\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (validateAll()) {\n      console.log('Form submitted:', values);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"max-w-md mx-auto p-6 bg-white rounded-lg shadow\">\n      <h2 className=\"text-2xl font-bold mb-6 text-center\">Login</h2>\n\n      <FormField\n        label=\"Email\"\n        name=\"email\"\n        type=\"email\"\n        value={values.email}\n        onChange={handleChange}\n        error={errors.email}\n        required\n        placeholder=\"Enter your email\"\n      />\n\n      <FormField\n        label=\"Password\"\n        name=\"password\"\n        type=\"password\"\n        value={values.password}\n        onChange={handleChange}\n        error={errors.password}\n        required\n        placeholder=\"Enter your password\"\n      />\n\n      <Button\n        type=\"submit\"\n        variant=\"primary\"\n        size=\"lg\"\n        className=\"w-full\"\n      >\n        Login\n      </Button>\n    </form>\n  );\n}\n```\n\nThis form pattern will inform all form implementation with proper validation and error handling.\n\nAll forms must include proper validation, error handling, and accessibility features.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "6. Error Handling and Loading States",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Error Boundary",
        "content": "```tsx\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div className=\"\n          // Layout\n          flex flex-col items-center justify-center\n\n          // Box model\n          p-8\n\n          // Visual\n          bg-red-50 border border-red-200 rounded-lg\n\n          // Typography\n          text-center\n        \">\n          <h2 className=\"text-xl font-semibold text-red-800 mb-2\">\n            Something went wrong\n          </h2>\n          <p className=\"text-red-600 mb-4\">\n            {this.state.error?.message || 'An unexpected error occurred'}\n          </p>\n          <button\n            onClick={() => this.setState({ hasError: false })}\n            className=\"px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n          >\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\nThis error boundary pattern will inform all error handling implementation.\n\nAll applications must include proper error boundaries and error handling.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Loading States",
        "content": "```tsx\n// Loading component\nexport function LoadingSpinner({ size = 'md' }: { size?: 'sm' | 'md' | 'lg' }) {\n  const sizeClasses = {\n    sm: 'h-4 w-4',\n    md: 'h-8 w-8',\n    lg: 'h-12 w-12'\n  };\n\n  return (\n    <div className=\"flex justify-center items-center\">\n      <svg\n        className={`animate-spin ${sizeClasses[size]} text-blue-500`}\n        fill=\"none\"\n        viewBox=\"0 0 24 24\"\n      >\n        <circle\n          className=\"opacity-25\"\n          cx=\"12\"\n          cy=\"12\"\n          r=\"10\"\n          stroke=\"currentColor\"\n          strokeWidth=\"4\"\n        />\n        <path\n          className=\"opacity-75\"\n          fill=\"currentColor\"\n          d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n        />\n      </svg>\n    </div>\n  );\n}\n\n// Loading wrapper component\nexport function LoadingWrapper({\n  loading,\n  error,\n  children,\n  fallback\n}: {\n  loading: boolean;\n  error?: string | null;\n  children: ReactNode;\n  fallback?: ReactNode;\n}) {\n  if (loading) {\n    return fallback || (\n      <div className=\"flex justify-center items-center p-8\">\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"\n        // Layout\n        flex flex-col items-center justify-center\n\n        // Box model\n        p-8\n\n        // Visual\n        bg-red-50 border border-red-200 rounded-lg\n\n        // Typography\n        text-center\n      \">\n        <h3 className=\"text-lg font-semibold text-red-800 mb-2\">\n          Error Loading Content\n        </h3>\n        <p className=\"text-red-600\">{error}</p>\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n}\n```\n\nThis loading pattern will inform all loading state implementation.\n\nAll components must include proper loading states and error handling.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Implementation Guidelines",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "For AI Assistants",
        "content": "1. **Follow these patterns** for all React component implementation\n2. **Use TypeScript** with proper type definitions\n3. **Implement proper error handling** with error boundaries\n4. **Include loading states** for all async operations\n5. **Use Tailwind CSS** with proper organization\n6. **Follow responsive design** principles\n7. **Implement proper form validation** and error handling\n8. **Use appropriate state management** patterns",
        "subsections": []
      },
      {
        "level": 3,
        "title": "For Human Developers",
        "content": "1. **Reference these patterns** when building React components\n2. **Use TypeScript** for type safety and better development experience\n3. **Implement error boundaries** for robust error handling\n4. **Include loading states** for better user experience\n5. **Follow Tailwind CSS** organization patterns\n6. **Test components** thoroughly with different scenarios\n7. **Optimize performance** with proper React patterns",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Quality Assurance",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Component Standards",
        "content": "- All components must use TypeScript with proper interfaces\n- Components must follow single responsibility principle\n- Error handling must be comprehensive with error boundaries\n- Loading states must be implemented for async operations\n- Accessibility features must be included",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Performance Standards",
        "content": "- Components must use proper React optimization techniques\n- Bundle size must be optimized with code splitting\n- Images and assets must be optimized\n- Lazy loading must be implemented where appropriate\n- Performance must be monitored and measured",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Accessibility Standards",
        "content": "- Semantic HTML elements must be used\n- ARIA attributes must be properly implemented\n- Keyboard navigation must be supported\n- Color contrast must meet WCAG guidelines\n- Screen reader compatibility must be tested",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Testing Standards",
        "content": "- Unit tests must be written for all components\n- Integration tests must cover component interactions\n- Accessibility tests must be included\n- Performance tests must be implemented\n- Visual regression tests must be maintained\n\n---\n\n**AI Quality Checklist**: Before implementing React components, ensure:\n- [x] TypeScript interfaces are properly defined\n- [x] Components follow single responsibility principle\n- [x] Error boundaries are implemented\n- [x] Loading states are included for async operations\n- [x] Tailwind CSS classes are properly organized\n- [x] Responsive design principles are followed\n- [x] Form validation and error handling are implemented\n- [x] Accessibility features are included\n- [x] Performance optimization techniques are applied",
        "subsections": []
      }
    ],
    "code_blocks": [
      {
        "language": "tsx",
        "code": "import React, { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { OtherComponent } from \"../components/OtherComponent\";\n\ninterface ComponentNameProps {\n  title: string;\n  isActive?: boolean;\n  onAction?: (value: string) => void;\n}\n\nexport function ComponentName({ title, isActive = false, onAction }: ComponentNameProps) {\n  const [localState, setLocalState] = useState<string>(\"\");\n\n  useEffect(() => {\n    // Component initialization logic\n    console.log(\"Component mounted\");\n\n    return () => {\n      // Cleanup logic\n      console.log(\"Component unmounted\");\n    };\n  }, []);\n\n  const handleClick = () => {\n    if (onAction) {\n      onAction(localState);\n    }\n  };\n\n  return (\n    <div className=\"\n      // Layout\n      flex items-center justify-between\n\n      // Box model\n      p-4 m-2\n\n      // Visual\n      bg-white shadow-sm rounded-lg\n\n      // Typography\n      text-gray-900\n\n      // Transitions\n      transition-colors duration-200\n\n      // Conditional styling\n      hover:bg-gray-50\n      ${isActive ? 'border-blue-500' : 'border-gray-200'}\n    \">\n      <h2 className=\"text-xl font-semibold\">{title}</h2>\n      <button\n        onClick={handleClick}\n        className=\"\n          px-4 py-2\n          bg-blue-500 text-white\n          rounded-md\n          hover:bg-blue-600\n          transition-colors duration-200\n        \"\n      >\n        Action\n      </button>\n    </div>\n  );\n}"
      },
      {
        "language": "tsx",
        "code": "// Common type definitions\nexport interface User {\n  id: number;\n  email: string;\n  username: string;\n  isActive: boolean;\n  createdAt: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  message?: string;\n  error?: string;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  perPage: number;\n  totalPages: number;\n}\n\n// Component prop types\nexport interface ButtonProps {\n  children: React.ReactNode;\n  variant?: 'primary' | 'secondary' | 'danger';\n  size?: 'sm' | 'md' | 'lg';\n  disabled?: boolean;\n  loading?: boolean;\n  onClick?: () => void;\n  className?: string;\n}\n\n// Form types\nexport interface FormData {\n  email: string;\n  password: string;\n  rememberMe?: boolean;\n}\n\nexport interface FormErrors {\n  email?: string;\n  password?: string;\n  general?: string;\n}"
      },
      {
        "language": "tsx",
        "code": "import { useState, useEffect, useCallback, useMemo } from 'react';\n\n// Custom hook for API calls\nexport function useApiCall<T>(\n  apiFunction: () => Promise<T>,\n  dependencies: React.DependencyList = []\n) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchData = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const result = await apiFunction();\n      setData(result);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'An error occurred');\n    } finally {\n      setLoading(false);\n    }\n  }, dependencies);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return { data, loading, error, refetch: fetchData };\n}\n\n// Custom hook for form management\nexport function useForm<T extends Record<string, any>>(initialValues: T) {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});\n\n  const handleChange = useCallback((name: keyof T, value: any) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    // Clear error when user starts typing\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: undefined }));\n    }\n  }, [errors]);\n\n  const handleSubmit = useCallback((onSubmit: (values: T) => void) => {\n    return (e: React.FormEvent) => {\n      e.preventDefault();\n      onSubmit(values);\n    };\n  }, [values]);\n\n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n  }, [initialValues]);\n\n  return {\n    values,\n    errors,\n    handleChange,\n    handleSubmit,\n    reset,\n    setErrors\n  };\n}"
      },
      {
        "language": "tsx",
        "code": "import React, { useState, useReducer, useCallback } from 'react';\n\n// Simple state management\nexport function SimpleStateComponent() {\n  const [count, setCount] = useState<number>(0);\n  const [isVisible, setIsVisible] = useState<boolean>(true);\n\n  const increment = useCallback(() => {\n    setCount(prev => prev + 1);\n  }, []);\n\n  const toggleVisibility = useCallback(() => {\n    setIsVisible(prev => !prev);\n  }, []);\n\n  return (\n    <div className=\"p-4\">\n      {isVisible && (\n        <div className=\"text-center\">\n          <h2 className=\"text-2xl font-bold\">Count: {count}</h2>\n          <button\n            onClick={increment}\n            className=\"mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n          >\n            Increment\n          </button>\n        </div>\n      )}\n      <button\n        onClick={toggleVisibility}\n        className=\"mt-4 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600\"\n      >\n        {isVisible ? 'Hide' : 'Show'}\n      </button>\n    </div>\n  );\n}\n\n// Complex state management with useReducer\ninterface TodoState {\n  todos: Todo[];\n  filter: 'all' | 'active' | 'completed';\n  loading: boolean;\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ntype TodoAction =\n  | { type: 'ADD_TODO'; payload: string }\n  | { type: 'TOGGLE_TODO'; payload: number }\n  | { type: 'SET_FILTER'; payload: 'all' | 'active' | 'completed' }\n  | { type: 'SET_LOADING'; payload: boolean };\n\nfunction todoReducer(state: TodoState, action: TodoAction): TodoState {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        ...state,\n        todos: [...state.todos, {\n          id: Date.now(),\n          text: action.payload,\n          completed: false\n        }]\n      };\n    case 'TOGGLE_TODO':\n      return {\n        ...state,\n        todos: state.todos.map(todo =>\n          todo.id === action.payload\n            ? { ...todo, completed: !todo.completed }\n            : todo\n        )\n      };\n    case 'SET_FILTER':\n      return { ...state, filter: action.payload };\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    default:\n      return state;\n  }\n}\n\nexport function TodoList() {\n  const [state, dispatch] = useReducer(todoReducer, {\n    todos: [],\n    filter: 'all',\n    loading: false\n  });\n  const [newTodo, setNewTodo] = useState<string>('');\n\n  const addTodo = useCallback(() => {\n    if (newTodo.trim()) {\n      dispatch({ type: 'ADD_TODO', payload: newTodo.trim() });\n      setNewTodo('');\n    }\n  }, [newTodo]);\n\n  const filteredTodos = useMemo(() => {\n    switch (state.filter) {\n      case 'active':\n        return state.todos.filter(todo => !todo.completed);\n      case 'completed':\n        return state.todos.filter(todo => todo.completed);\n      default:\n        return state.todos;\n    }\n  }, [state.todos, state.filter]);\n\n  return (\n    <div className=\"max-w-md mx-auto p-4\">\n      <h1 className=\"text-2xl font-bold mb-4\">Todo List</h1>\n\n      <div className=\"flex gap-2 mb-4\">\n        <input\n          type=\"text\"\n          value={newTodo}\n          onChange={(e) => setNewTodo(e.target.value)}\n          onKeyPress={(e) => e.key === 'Enter' && addTodo()}\n          placeholder=\"Add new todo...\"\n          className=\"flex-1 px-3 py-2 border rounded\"\n        />\n        <button\n          onClick={addTodo}\n          className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n        >\n          Add\n        </button>\n      </div>\n\n      <div className=\"flex gap-2 mb-4\">\n        {(['all', 'active', 'completed'] as const).map(filter => (\n          <button\n            key={filter}\n            onClick={() => dispatch({ type: 'SET_FILTER', payload: filter })}\n            className={`px-3 py-1 rounded ${\n              state.filter === filter\n                ? 'bg-blue-500 text-white'\n                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'\n            }`}\n          >\n            {filter.charAt(0).toUpperCase() + filter.slice(1)}\n          </button>\n        ))}\n      </div>\n\n      <ul className=\"space-y-2\">\n        {filteredTodos.map(todo => (\n          <li\n            key={todo.id}\n            className=\"flex items-center gap-2 p-2 border rounded\"\n          >\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}\n              className=\"rounded\"\n            />\n            <span className={todo.completed ? 'line-through text-gray-500' : ''}>\n              {todo.text}\n            </span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}"
      },
      {
        "language": "tsx",
        "code": "// Reusable style components\nconst buttonVariants = {\n  primary: \"bg-blue-500 text-white hover:bg-blue-600 focus:ring-blue-500\",\n  secondary: \"bg-gray-500 text-white hover:bg-gray-600 focus:ring-gray-500\",\n  danger: \"bg-red-500 text-white hover:bg-red-600 focus:ring-red-500\",\n  outline: \"border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-gray-500\"\n};\n\nconst buttonSizes = {\n  sm: \"px-3 py-1.5 text-sm\",\n  md: \"px-4 py-2 text-base\",\n  lg: \"px-6 py-3 text-lg\"\n};\n\ninterface ButtonProps {\n  children: React.ReactNode;\n  variant?: keyof typeof buttonVariants;\n  size?: keyof typeof buttonSizes;\n  disabled?: boolean;\n  loading?: boolean;\n  onClick?: () => void;\n  className?: string;\n}\n\nexport function Button({\n  children,\n  variant = 'primary',\n  size = 'md',\n  disabled = false,\n  loading = false,\n  onClick,\n  className = ''\n}: ButtonProps) {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled || loading}\n      className={`\n        // Layout\n        inline-flex items-center justify-center\n\n        // Box model\n        ${buttonSizes[size]}\n\n        // Visual\n        ${buttonVariants[variant]}\n        rounded-md font-medium\n\n        // Typography\n        font-medium\n\n        // Transitions\n        transition-colors duration-200\n\n        // States\n        focus:outline-none focus:ring-2 focus:ring-offset-2\n        disabled:opacity-50 disabled:cursor-not-allowed\n\n        // Custom classes\n        ${className}\n      `}\n    >\n      {loading && (\n        <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\">\n          <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\n          <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\n        </svg>\n      )}\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "tsx",
        "code": "// Responsive component example\nexport function ResponsiveCard() {\n  return (\n    <div className=\"\n      // Layout - responsive grid\n      grid grid-cols-1\n      sm:grid-cols-2\n      lg:grid-cols-3\n      xl:grid-cols-4\n\n      // Box model - responsive spacing\n      gap-4\n      p-4\n      sm:p-6\n      lg:p-8\n\n      // Visual\n      bg-white shadow-lg rounded-lg\n\n      // Typography - responsive text sizes\n      text-sm\n      sm:text-base\n      lg:text-lg\n    \">\n      <div className=\"\n        // Layout\n        flex flex-col\n\n        // Box model\n        p-4\n        sm:p-6\n\n        // Visual\n        bg-gray-50 rounded-lg\n\n        // Typography\n        text-center\n      \">\n        <h3 className=\"\n          text-lg\n          sm:text-xl\n          lg:text-2xl\n          font-bold\n          text-gray-900\n          mb-2\n        \">\n          Card Title\n        </h3>\n        <p className=\"\n          text-sm\n          sm:text-base\n          text-gray-600\n        \">\n          Responsive content that adapts to different screen sizes\n        </p>\n      </div>\n    </div>\n  );\n}"
      },
      {
        "language": "tsx",
        "code": "import React, { useState } from 'react';\n\ninterface FormFieldProps {\n  label: string;\n  name: string;\n  type?: 'text' | 'email' | 'password' | 'number';\n  value: string;\n  onChange: (name: string, value: string) => void;\n  error?: string;\n  required?: boolean;\n  placeholder?: string;\n}\n\nexport function FormField({\n  label,\n  name,\n  type = 'text',\n  value,\n  onChange,\n  error,\n  required = false,\n  placeholder\n}: FormFieldProps) {\n  return (\n    <div className=\"mb-4\">\n      <label htmlFor={name} className=\"\n        block\n        text-sm\n        font-medium\n        text-gray-700\n        mb-1\n      \">\n        {label}\n        {required && <span className=\"text-red-500 ml-1\">*</span>}\n      </label>\n      <input\n        id={name}\n        type={type}\n        value={value}\n        onChange={(e) => onChange(name, e.target.value)}\n        placeholder={placeholder}\n        className={`\n          // Layout\n          block w-full\n\n          // Box model\n          px-3 py-2\n\n          // Visual\n          border rounded-md\n          ${error ? 'border-red-500' : 'border-gray-300'}\n          focus:outline-none focus:ring-2\n          ${error ? 'focus:ring-red-500' : 'focus:ring-blue-500'}\n          focus:border-transparent\n\n          // Typography\n          text-sm\n\n          // Transitions\n          transition-colors duration-200\n        `}\n      />\n      {error && (\n        <p className=\"mt-1 text-sm text-red-600\">{error}</p>\n      )}\n    </div>\n  );\n}\n\n// Form validation\nexport function useFormValidation<T extends Record<string, any>>(\n  initialValues: T,\n  validationRules: Record<keyof T, (value: any) => string | undefined>\n) {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});\n\n  const validate = (name: keyof T, value: any): string | undefined => {\n    const rule = validationRules[name];\n    return rule ? rule(value) : undefined;\n  };\n\n  const handleChange = (name: keyof T, value: any) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    const error = validate(name, value);\n    setErrors(prev => ({ ...prev, [name]: error }));\n  };\n\n  const validateAll = (): boolean => {\n    const newErrors: Partial<Record<keyof T, string>> = {};\n    let isValid = true;\n\n    Object.keys(validationRules).forEach(key => {\n      const name = key as keyof T;\n      const error = validate(name, values[name]);\n      if (error) {\n        newErrors[name] = error;\n        isValid = false;\n      }\n    });\n\n    setErrors(newErrors);\n    return isValid;\n  };\n\n  return {\n    values,\n    errors,\n    handleChange,\n    validateAll,\n    setValues\n  };\n}\n\n// Usage example\nexport function LoginForm() {\n  const validationRules = {\n    email: (value: string) => {\n      if (!value) return 'Email is required';\n      if (!/\\S+@\\S+\\.\\S+/.test(value)) return 'Email is invalid';\n      return undefined;\n    },\n    password: (value: string) => {\n      if (!value) return 'Password is required';\n      if (value.length < 6) return 'Password must be at least 6 characters';\n      return undefined;\n    }\n  };\n\n  const { values, errors, handleChange, validateAll } = useFormValidation(\n    { email: '', password: '' },\n    validationRules\n  );\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (validateAll()) {\n      console.log('Form submitted:', values);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"max-w-md mx-auto p-6 bg-white rounded-lg shadow\">\n      <h2 className=\"text-2xl font-bold mb-6 text-center\">Login</h2>\n\n      <FormField\n        label=\"Email\"\n        name=\"email\"\n        type=\"email\"\n        value={values.email}\n        onChange={handleChange}\n        error={errors.email}\n        required\n        placeholder=\"Enter your email\"\n      />\n\n      <FormField\n        label=\"Password\"\n        name=\"password\"\n        type=\"password\"\n        value={values.password}\n        onChange={handleChange}\n        error={errors.password}\n        required\n        placeholder=\"Enter your password\"\n      />\n\n      <Button\n        type=\"submit\"\n        variant=\"primary\"\n        size=\"lg\"\n        className=\"w-full\"\n      >\n        Login\n      </Button>\n    </form>\n  );\n}"
      },
      {
        "language": "tsx",
        "code": "import React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div className=\"\n          // Layout\n          flex flex-col items-center justify-center\n\n          // Box model\n          p-8\n\n          // Visual\n          bg-red-50 border border-red-200 rounded-lg\n\n          // Typography\n          text-center\n        \">\n          <h2 className=\"text-xl font-semibold text-red-800 mb-2\">\n            Something went wrong\n          </h2>\n          <p className=\"text-red-600 mb-4\">\n            {this.state.error?.message || 'An unexpected error occurred'}\n          </p>\n          <button\n            onClick={() => this.setState({ hasError: false })}\n            className=\"px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n          >\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}"
      },
      {
        "language": "tsx",
        "code": "// Loading component\nexport function LoadingSpinner({ size = 'md' }: { size?: 'sm' | 'md' | 'lg' }) {\n  const sizeClasses = {\n    sm: 'h-4 w-4',\n    md: 'h-8 w-8',\n    lg: 'h-12 w-12'\n  };\n\n  return (\n    <div className=\"flex justify-center items-center\">\n      <svg\n        className={`animate-spin ${sizeClasses[size]} text-blue-500`}\n        fill=\"none\"\n        viewBox=\"0 0 24 24\"\n      >\n        <circle\n          className=\"opacity-25\"\n          cx=\"12\"\n          cy=\"12\"\n          r=\"10\"\n          stroke=\"currentColor\"\n          strokeWidth=\"4\"\n        />\n        <path\n          className=\"opacity-75\"\n          fill=\"currentColor\"\n          d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n        />\n      </svg>\n    </div>\n  );\n}\n\n// Loading wrapper component\nexport function LoadingWrapper({\n  loading,\n  error,\n  children,\n  fallback\n}: {\n  loading: boolean;\n  error?: string | null;\n  children: ReactNode;\n  fallback?: ReactNode;\n}) {\n  if (loading) {\n    return fallback || (\n      <div className=\"flex justify-center items-center p-8\">\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"\n        // Layout\n        flex flex-col items-center justify-center\n\n        // Box model\n        p-8\n\n        // Visual\n        bg-red-50 border border-red-200 rounded-lg\n\n        // Typography\n        text-center\n      \">\n        <h3 className=\"text-lg font-semibold text-red-800 mb-2\">\n          Error Loading Content\n        </h3>\n        <p className=\"text-red-600\">{error}</p>\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n}"
      }
    ],
    "links": [
      {
        "type": "code_reference",
        "text": "../Core%20Principles.md"
      },
      {
        "type": "code_reference",
        "text": "../Language-Specific/Python%20Testing%20Guide.md"
      },
      {
        "type": "code_reference",
        "text": "../../project_context/Architecture%20Overview.md"
      },
      {
        "type": "code_reference",
        "text": "../../project_context/Common%20Patterns.md"
      },
      {
        "type": "code_reference",
        "text": "Navbar.tsx"
      },
      {
        "type": "code_reference",
        "text": "LandingPage.tsx"
      },
      {
        "type": "code_reference",
        "text": "tsx\nimport React, { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { OtherComponent } from \"../components/OtherComponent\";\n\ninterface ComponentNameProps {\n  title: string;\n  isActive?: boolean;\n  onAction?: (value: string) => void;\n}\n\nexport function ComponentName({ title, isActive = false, onAction }: ComponentNameProps) {\n  const [localState, setLocalState] = useState<string>(\"\");\n\n  useEffect(() => {\n    // Component initialization logic\n    console.log(\"Component mounted\");\n\n    return () => {\n      // Cleanup logic\n      console.log(\"Component unmounted\");\n    };\n  }, []);\n\n  const handleClick = () => {\n    if (onAction) {\n      onAction(localState);\n    }\n  };\n\n  return (\n    <div className=\"\n      // Layout\n      flex items-center justify-between\n\n      // Box model\n      p-4 m-2\n\n      // Visual\n      bg-white shadow-sm rounded-lg\n\n      // Typography\n      text-gray-900\n\n      // Transitions\n      transition-colors duration-200\n\n      // Conditional styling\n      hover:bg-gray-50\n      ${isActive ? 'border-blue-500' : 'border-gray-200'}\n    \">\n      <h2 className=\"text-xl font-semibold\">{title}</h2>\n      <button\n        onClick={handleClick}\n        className=\"\n          px-4 py-2\n          bg-blue-500 text-white\n          rounded-md\n          hover:bg-blue-600\n          transition-colors duration-200\n        \"\n      >\n        Action\n      </button>\n    </div>\n  );\n}\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis component pattern will inform all React component implementation with proper TypeScript and styling.\n\nAll components must include proper TypeScript interfaces, error handling, and Tailwind CSS organization.\n\n### Import Considerations\n- @import must precede all other statements (besides @charset or empty @layer)\n- The first import should always be "
      },
      {
        "type": "code_reference",
        "text": ", if needed.\n- "
      },
      {
        "type": "code_reference",
        "text": " should always be above it.\n\nThis import pattern will inform all component import organization.\n\nAll imports must follow this organization pattern.\n\n## 2. TypeScript Patterns\n\n### Type Definitions\n"
      },
      {
        "type": "code_reference",
        "text": "tsx\n// Common type definitions\nexport interface User {\n  id: number;\n  email: string;\n  username: string;\n  isActive: boolean;\n  createdAt: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  message?: string;\n  error?: string;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  perPage: number;\n  totalPages: number;\n}\n\n// Component prop types\nexport interface ButtonProps {\n  children: React.ReactNode;\n  variant?: 'primary' | 'secondary' | 'danger';\n  size?: 'sm' | 'md' | 'lg';\n  disabled?: boolean;\n  loading?: boolean;\n  onClick?: () => void;\n  className?: string;\n}\n\n// Form types\nexport interface FormData {\n  email: string;\n  password: string;\n  rememberMe?: boolean;\n}\n\nexport interface FormErrors {\n  email?: string;\n  password?: string;\n  general?: string;\n}\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis type pattern will inform all TypeScript type definition implementation.\n\nAll components must include proper TypeScript interfaces and type definitions.\n\n### Hook Patterns\n"
      },
      {
        "type": "code_reference",
        "text": "tsx\nimport { useState, useEffect, useCallback, useMemo } from 'react';\n\n// Custom hook for API calls\nexport function useApiCall<T>(\n  apiFunction: () => Promise<T>,\n  dependencies: React.DependencyList = []\n) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchData = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const result = await apiFunction();\n      setData(result);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'An error occurred');\n    } finally {\n      setLoading(false);\n    }\n  }, dependencies);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return { data, loading, error, refetch: fetchData };\n}\n\n// Custom hook for form management\nexport function useForm<T extends Record<string, any>>(initialValues: T) {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});\n\n  const handleChange = useCallback((name: keyof T, value: any) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    // Clear error when user starts typing\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: undefined }));\n    }\n  }, [errors]);\n\n  const handleSubmit = useCallback((onSubmit: (values: T) => void) => {\n    return (e: React.FormEvent) => {\n      e.preventDefault();\n      onSubmit(values);\n    };\n  }, [values]);\n\n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n  }, [initialValues]);\n\n  return {\n    values,\n    errors,\n    handleChange,\n    handleSubmit,\n    reset,\n    setErrors\n  };\n}\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis hook pattern will inform all custom hook implementation with proper TypeScript and error handling.\n\nAll custom hooks must include proper TypeScript types and error handling.\n\n## 3. State Management\n\n### Component State\n"
      },
      {
        "type": "code_reference",
        "text": "tsx\nimport React, { useState, useReducer, useCallback } from 'react';\n\n// Simple state management\nexport function SimpleStateComponent() {\n  const [count, setCount] = useState<number>(0);\n  const [isVisible, setIsVisible] = useState<boolean>(true);\n\n  const increment = useCallback(() => {\n    setCount(prev => prev + 1);\n  }, []);\n\n  const toggleVisibility = useCallback(() => {\n    setIsVisible(prev => !prev);\n  }, []);\n\n  return (\n    <div className=\"p-4\">\n      {isVisible && (\n        <div className=\"text-center\">\n          <h2 className=\"text-2xl font-bold\">Count: {count}</h2>\n          <button\n            onClick={increment}\n            className=\"mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n          >\n            Increment\n          </button>\n        </div>\n      )}\n      <button\n        onClick={toggleVisibility}\n        className=\"mt-4 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600\"\n      >\n        {isVisible ? 'Hide' : 'Show'}\n      </button>\n    </div>\n  );\n}\n\n// Complex state management with useReducer\ninterface TodoState {\n  todos: Todo[];\n  filter: 'all' | 'active' | 'completed';\n  loading: boolean;\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ntype TodoAction =\n  | { type: 'ADD_TODO'; payload: string }\n  | { type: 'TOGGLE_TODO'; payload: number }\n  | { type: 'SET_FILTER'; payload: 'all' | 'active' | 'completed' }\n  | { type: 'SET_LOADING'; payload: boolean };\n\nfunction todoReducer(state: TodoState, action: TodoAction): TodoState {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        ...state,\n        todos: [...state.todos, {\n          id: Date.now(),\n          text: action.payload,\n          completed: false\n        }]\n      };\n    case 'TOGGLE_TODO':\n      return {\n        ...state,\n        todos: state.todos.map(todo =>\n          todo.id === action.payload\n            ? { ...todo, completed: !todo.completed }\n            : todo\n        )\n      };\n    case 'SET_FILTER':\n      return { ...state, filter: action.payload };\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    default:\n      return state;\n  }\n}\n\nexport function TodoList() {\n  const [state, dispatch] = useReducer(todoReducer, {\n    todos: [],\n    filter: 'all',\n    loading: false\n  });\n  const [newTodo, setNewTodo] = useState<string>('');\n\n  const addTodo = useCallback(() => {\n    if (newTodo.trim()) {\n      dispatch({ type: 'ADD_TODO', payload: newTodo.trim() });\n      setNewTodo('');\n    }\n  }, [newTodo]);\n\n  const filteredTodos = useMemo(() => {\n    switch (state.filter) {\n      case 'active':\n        return state.todos.filter(todo => !todo.completed);\n      case 'completed':\n        return state.todos.filter(todo => todo.completed);\n      default:\n        return state.todos;\n    }\n  }, [state.todos, state.filter]);\n\n  return (\n    <div className=\"max-w-md mx-auto p-4\">\n      <h1 className=\"text-2xl font-bold mb-4\">Todo List</h1>\n\n      <div className=\"flex gap-2 mb-4\">\n        <input\n          type=\"text\"\n          value={newTodo}\n          onChange={(e) => setNewTodo(e.target.value)}\n          onKeyPress={(e) => e.key === 'Enter' && addTodo()}\n          placeholder=\"Add new todo...\"\n          className=\"flex-1 px-3 py-2 border rounded\"\n        />\n        <button\n          onClick={addTodo}\n          className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n        >\n          Add\n        </button>\n      </div>\n\n      <div className=\"flex gap-2 mb-4\">\n        {(['all', 'active', 'completed'] as const).map(filter => (\n          <button\n            key={filter}\n            onClick={() => dispatch({ type: 'SET_FILTER', payload: filter })}\n            className={"
      },
      {
        "type": "code_reference",
        "text": "}\n          >\n            {filter.charAt(0).toUpperCase() + filter.slice(1)}\n          </button>\n        ))}\n      </div>\n\n      <ul className=\"space-y-2\">\n        {filteredTodos.map(todo => (\n          <li\n            key={todo.id}\n            className=\"flex items-center gap-2 p-2 border rounded\"\n          >\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}\n              className=\"rounded\"\n            />\n            <span className={todo.completed ? 'line-through text-gray-500' : ''}>\n              {todo.text}\n            </span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis state management pattern will inform all React state implementation with proper TypeScript and performance optimization.\n\nAll state management must use appropriate React patterns and include proper TypeScript types.\n\n## 4. Styling with Tailwind CSS\n\n### Class Organization\n- Group related classes together\n- Use consistent spacing between class groups\n- Follow this order:\n  1. Layout (display, position, etc.)\n  2. Box model (margin, padding, etc.)\n  3. Visual (colors, backgrounds, etc.)\n  4. Typography\n  5. Transitions/Animations\n\nThis class organization will inform all Tailwind CSS implementation.\n\nAll Tailwind classes must follow this organization pattern.\n\n### Component Styling Patterns\n"
      },
      {
        "type": "code_reference",
        "text": "tsx\n// Reusable style components\nconst buttonVariants = {\n  primary: \"bg-blue-500 text-white hover:bg-blue-600 focus:ring-blue-500\",\n  secondary: \"bg-gray-500 text-white hover:bg-gray-600 focus:ring-gray-500\",\n  danger: \"bg-red-500 text-white hover:bg-red-600 focus:ring-red-500\",\n  outline: \"border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-gray-500\"\n};\n\nconst buttonSizes = {\n  sm: \"px-3 py-1.5 text-sm\",\n  md: \"px-4 py-2 text-base\",\n  lg: \"px-6 py-3 text-lg\"\n};\n\ninterface ButtonProps {\n  children: React.ReactNode;\n  variant?: keyof typeof buttonVariants;\n  size?: keyof typeof buttonSizes;\n  disabled?: boolean;\n  loading?: boolean;\n  onClick?: () => void;\n  className?: string;\n}\n\nexport function Button({\n  children,\n  variant = 'primary',\n  size = 'md',\n  disabled = false,\n  loading = false,\n  onClick,\n  className = ''\n}: ButtonProps) {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled || loading}\n      className={"
      },
      {
        "type": "code_reference",
        "text": "}\n    >\n      {loading && (\n        <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\">\n          <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\n          <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\n        </svg>\n      )}\n      {children}\n    </button>\n  );\n}\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis styling pattern will inform all component styling implementation with reusable variants.\n\nAll component styling must use consistent patterns and include proper state handling.\n\n### Responsive Design\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis responsive pattern will inform all responsive design implementation.\n\nAll responsive components must use mobile-first design principles.\n\n## 5. Form Handling\n\n### Form Components\n"
      },
      {
        "type": "code_reference",
        "text": "tsx\nimport React, { useState } from 'react';\n\ninterface FormFieldProps {\n  label: string;\n  name: string;\n  type?: 'text' | 'email' | 'password' | 'number';\n  value: string;\n  onChange: (name: string, value: string) => void;\n  error?: string;\n  required?: boolean;\n  placeholder?: string;\n}\n\nexport function FormField({\n  label,\n  name,\n  type = 'text',\n  value,\n  onChange,\n  error,\n  required = false,\n  placeholder\n}: FormFieldProps) {\n  return (\n    <div className=\"mb-4\">\n      <label htmlFor={name} className=\"\n        block\n        text-sm\n        font-medium\n        text-gray-700\n        mb-1\n      \">\n        {label}\n        {required && <span className=\"text-red-500 ml-1\">*</span>}\n      </label>\n      <input\n        id={name}\n        type={type}\n        value={value}\n        onChange={(e) => onChange(name, e.target.value)}\n        placeholder={placeholder}\n        className={"
      },
      {
        "type": "code_reference",
        "text": "}\n      />\n      {error && (\n        <p className=\"mt-1 text-sm text-red-600\">{error}</p>\n      )}\n    </div>\n  );\n}\n\n// Form validation\nexport function useFormValidation<T extends Record<string, any>>(\n  initialValues: T,\n  validationRules: Record<keyof T, (value: any) => string | undefined>\n) {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});\n\n  const validate = (name: keyof T, value: any): string | undefined => {\n    const rule = validationRules[name];\n    return rule ? rule(value) : undefined;\n  };\n\n  const handleChange = (name: keyof T, value: any) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    const error = validate(name, value);\n    setErrors(prev => ({ ...prev, [name]: error }));\n  };\n\n  const validateAll = (): boolean => {\n    const newErrors: Partial<Record<keyof T, string>> = {};\n    let isValid = true;\n\n    Object.keys(validationRules).forEach(key => {\n      const name = key as keyof T;\n      const error = validate(name, values[name]);\n      if (error) {\n        newErrors[name] = error;\n        isValid = false;\n      }\n    });\n\n    setErrors(newErrors);\n    return isValid;\n  };\n\n  return {\n    values,\n    errors,\n    handleChange,\n    validateAll,\n    setValues\n  };\n}\n\n// Usage example\nexport function LoginForm() {\n  const validationRules = {\n    email: (value: string) => {\n      if (!value) return 'Email is required';\n      if (!/\\S+@\\S+\\.\\S+/.test(value)) return 'Email is invalid';\n      return undefined;\n    },\n    password: (value: string) => {\n      if (!value) return 'Password is required';\n      if (value.length < 6) return 'Password must be at least 6 characters';\n      return undefined;\n    }\n  };\n\n  const { values, errors, handleChange, validateAll } = useFormValidation(\n    { email: '', password: '' },\n    validationRules\n  );\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (validateAll()) {\n      console.log('Form submitted:', values);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"max-w-md mx-auto p-6 bg-white rounded-lg shadow\">\n      <h2 className=\"text-2xl font-bold mb-6 text-center\">Login</h2>\n\n      <FormField\n        label=\"Email\"\n        name=\"email\"\n        type=\"email\"\n        value={values.email}\n        onChange={handleChange}\n        error={errors.email}\n        required\n        placeholder=\"Enter your email\"\n      />\n\n      <FormField\n        label=\"Password\"\n        name=\"password\"\n        type=\"password\"\n        value={values.password}\n        onChange={handleChange}\n        error={errors.password}\n        required\n        placeholder=\"Enter your password\"\n      />\n\n      <Button\n        type=\"submit\"\n        variant=\"primary\"\n        size=\"lg\"\n        className=\"w-full\"\n      >\n        Login\n      </Button>\n    </form>\n  );\n}\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis form pattern will inform all form implementation with proper validation and error handling.\n\nAll forms must include proper validation, error handling, and accessibility features.\n\n## 6. Error Handling and Loading States\n\n### Error Boundary\n"
      },
      {
        "type": "code_reference",
        "text": "tsx\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div className=\"\n          // Layout\n          flex flex-col items-center justify-center\n\n          // Box model\n          p-8\n\n          // Visual\n          bg-red-50 border border-red-200 rounded-lg\n\n          // Typography\n          text-center\n        \">\n          <h2 className=\"text-xl font-semibold text-red-800 mb-2\">\n            Something went wrong\n          </h2>\n          <p className=\"text-red-600 mb-4\">\n            {this.state.error?.message || 'An unexpected error occurred'}\n          </p>\n          <button\n            onClick={() => this.setState({ hasError: false })}\n            className=\"px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n          >\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis error boundary pattern will inform all error handling implementation.\n\nAll applications must include proper error boundaries and error handling.\n\n### Loading States\n"
      },
      {
        "type": "code_reference",
        "text": "}\n        fill=\"none\"\n        viewBox=\"0 0 24 24\"\n      >\n        <circle\n          className=\"opacity-25\"\n          cx=\"12\"\n          cy=\"12\"\n          r=\"10\"\n          stroke=\"currentColor\"\n          strokeWidth=\"4\"\n        />\n        <path\n          className=\"opacity-75\"\n          fill=\"currentColor\"\n          d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n        />\n      </svg>\n    </div>\n  );\n}\n\n// Loading wrapper component\nexport function LoadingWrapper({\n  loading,\n  error,\n  children,\n  fallback\n}: {\n  loading: boolean;\n  error?: string | null;\n  children: ReactNode;\n  fallback?: ReactNode;\n}) {\n  if (loading) {\n    return fallback || (\n      <div className=\"flex justify-center items-center p-8\">\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"\n        // Layout\n        flex flex-col items-center justify-center\n\n        // Box model\n        p-8\n\n        // Visual\n        bg-red-50 border border-red-200 rounded-lg\n\n        // Typography\n        text-center\n      \">\n        <h3 className=\"text-lg font-semibold text-red-800 mb-2\">\n          Error Loading Content\n        </h3>\n        <p className=\"text-red-600\">{error}</p>\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n}\n"
      }
    ],
    "raw_content": "# Frontend Style Guide\n\n> This guide provides comprehensive patterns and best practices for frontend development. Use these patterns to create consistent, maintainable user interfaces.\n\n## AI Metadata\n\n**Template Version:** 2.1\n**AI Processing Level:** High\n**Required Context:** React, TypeScript, Tailwind CSS, modern frontend development\n**Validation Required:** Yes\n**Code Generation:** Supported\n\n**Dependencies:**\n- `../Core%20Principles.md` - Decision-making frameworks\n- `../Language-Specific/Python%20Testing%20Guide.md` - Testing patterns\n- `../../project_context/Architecture%20Overview.md` - System architecture\n- `../../project_context/Common%20Patterns.md` - Project-specific patterns\n\n**Validation Rules:**\n- All components must use TypeScript with proper type definitions\n- Components must follow single responsibility principle\n- State management must use appropriate React patterns\n- Styling must use Tailwind CSS with proper organization\n- All components must include proper error handling and loading states\n\n## Overview\n\n**Document Purpose:** React/TypeScript development standards and best practices for the CreamPie project\n**Scope:** Component development, state management, styling, testing, and performance optimization\n**Target Users:** AI assistants and developers building React applications\n**Last Updated:** Current\n\n**AI Context:** This guide provides the foundational React patterns that must be followed for all frontend development in the project. It ensures maintainable, performant, and accessible React applications.\n\n## 1. Component Structure\n\n### File Organization\n- Place components in the `src/components` directory\n- Place pages in the `src/pages` directory\n- Use PascalCase for component file names (e.g., `Navbar.tsx`, `LandingPage.tsx`)\n\nThis organization will inform all component file placement and naming conventions.\n\nAll components must follow this file organization structure.\n\n### Component Naming\n- Use PascalCase for component names\n- Use descriptive names that indicate the component's purpose\n- Prefix page components with the page name (e.g., `LandingPage`)\n\nThis naming convention will inform all component naming decisions.\n\nAll component names must follow PascalCase and be descriptive.\n\n### Component Structure Patterns\n```tsx\nimport React, { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { OtherComponent } from \"../components/OtherComponent\";\n\ninterface ComponentNameProps {\n  title: string;\n  isActive?: boolean;\n  onAction?: (value: string) => void;\n}\n\nexport function ComponentName({ title, isActive = false, onAction }: ComponentNameProps) {\n  const [localState, setLocalState] = useState<string>(\"\");\n\n  useEffect(() => {\n    // Component initialization logic\n    console.log(\"Component mounted\");\n\n    return () => {\n      // Cleanup logic\n      console.log(\"Component unmounted\");\n    };\n  }, []);\n\n  const handleClick = () => {\n    if (onAction) {\n      onAction(localState);\n    }\n  };\n\n  return (\n    <div className=\"\n      // Layout\n      flex items-center justify-between\n\n      // Box model\n      p-4 m-2\n\n      // Visual\n      bg-white shadow-sm rounded-lg\n\n      // Typography\n      text-gray-900\n\n      // Transitions\n      transition-colors duration-200\n\n      // Conditional styling\n      hover:bg-gray-50\n      ${isActive ? 'border-blue-500' : 'border-gray-200'}\n    \">\n      <h2 className=\"text-xl font-semibold\">{title}</h2>\n      <button\n        onClick={handleClick}\n        className=\"\n          px-4 py-2\n          bg-blue-500 text-white\n          rounded-md\n          hover:bg-blue-600\n          transition-colors duration-200\n        \"\n      >\n        Action\n      </button>\n    </div>\n  );\n}\n```\n\nThis component pattern will inform all React component implementation with proper TypeScript and styling.\n\nAll components must include proper TypeScript interfaces, error handling, and Tailwind CSS organization.\n\n### Import Considerations\n- @import must precede all other statements (besides @charset or empty @layer)\n- The first import should always be `import * as React from \"react\";`, if needed.\n- `// @ts-expect-error - React is needed for JSX` should always be above it.\n\nThis import pattern will inform all component import organization.\n\nAll imports must follow this organization pattern.\n\n## 2. TypeScript Patterns\n\n### Type Definitions\n```tsx\n// Common type definitions\nexport interface User {\n  id: number;\n  email: string;\n  username: string;\n  isActive: boolean;\n  createdAt: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  message?: string;\n  error?: string;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  perPage: number;\n  totalPages: number;\n}\n\n// Component prop types\nexport interface ButtonProps {\n  children: React.ReactNode;\n  variant?: 'primary' | 'secondary' | 'danger';\n  size?: 'sm' | 'md' | 'lg';\n  disabled?: boolean;\n  loading?: boolean;\n  onClick?: () => void;\n  className?: string;\n}\n\n// Form types\nexport interface FormData {\n  email: string;\n  password: string;\n  rememberMe?: boolean;\n}\n\nexport interface FormErrors {\n  email?: string;\n  password?: string;\n  general?: string;\n}\n```\n\nThis type pattern will inform all TypeScript type definition implementation.\n\nAll components must include proper TypeScript interfaces and type definitions.\n\n### Hook Patterns\n```tsx\nimport { useState, useEffect, useCallback, useMemo } from 'react';\n\n// Custom hook for API calls\nexport function useApiCall<T>(\n  apiFunction: () => Promise<T>,\n  dependencies: React.DependencyList = []\n) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchData = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const result = await apiFunction();\n      setData(result);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'An error occurred');\n    } finally {\n      setLoading(false);\n    }\n  }, dependencies);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return { data, loading, error, refetch: fetchData };\n}\n\n// Custom hook for form management\nexport function useForm<T extends Record<string, any>>(initialValues: T) {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});\n\n  const handleChange = useCallback((name: keyof T, value: any) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    // Clear error when user starts typing\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: undefined }));\n    }\n  }, [errors]);\n\n  const handleSubmit = useCallback((onSubmit: (values: T) => void) => {\n    return (e: React.FormEvent) => {\n      e.preventDefault();\n      onSubmit(values);\n    };\n  }, [values]);\n\n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n  }, [initialValues]);\n\n  return {\n    values,\n    errors,\n    handleChange,\n    handleSubmit,\n    reset,\n    setErrors\n  };\n}\n```\n\nThis hook pattern will inform all custom hook implementation with proper TypeScript and error handling.\n\nAll custom hooks must include proper TypeScript types and error handling.\n\n## 3. State Management\n\n### Component State\n```tsx\nimport React, { useState, useReducer, useCallback } from 'react';\n\n// Simple state management\nexport function SimpleStateComponent() {\n  const [count, setCount] = useState<number>(0);\n  const [isVisible, setIsVisible] = useState<boolean>(true);\n\n  const increment = useCallback(() => {\n    setCount(prev => prev + 1);\n  }, []);\n\n  const toggleVisibility = useCallback(() => {\n    setIsVisible(prev => !prev);\n  }, []);\n\n  return (\n    <div className=\"p-4\">\n      {isVisible && (\n        <div className=\"text-center\">\n          <h2 className=\"text-2xl font-bold\">Count: {count}</h2>\n          <button\n            onClick={increment}\n            className=\"mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n          >\n            Increment\n          </button>\n        </div>\n      )}\n      <button\n        onClick={toggleVisibility}\n        className=\"mt-4 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600\"\n      >\n        {isVisible ? 'Hide' : 'Show'}\n      </button>\n    </div>\n  );\n}\n\n// Complex state management with useReducer\ninterface TodoState {\n  todos: Todo[];\n  filter: 'all' | 'active' | 'completed';\n  loading: boolean;\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ntype TodoAction =\n  | { type: 'ADD_TODO'; payload: string }\n  | { type: 'TOGGLE_TODO'; payload: number }\n  | { type: 'SET_FILTER'; payload: 'all' | 'active' | 'completed' }\n  | { type: 'SET_LOADING'; payload: boolean };\n\nfunction todoReducer(state: TodoState, action: TodoAction): TodoState {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        ...state,\n        todos: [...state.todos, {\n          id: Date.now(),\n          text: action.payload,\n          completed: false\n        }]\n      };\n    case 'TOGGLE_TODO':\n      return {\n        ...state,\n        todos: state.todos.map(todo =>\n          todo.id === action.payload\n            ? { ...todo, completed: !todo.completed }\n            : todo\n        )\n      };\n    case 'SET_FILTER':\n      return { ...state, filter: action.payload };\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    default:\n      return state;\n  }\n}\n\nexport function TodoList() {\n  const [state, dispatch] = useReducer(todoReducer, {\n    todos: [],\n    filter: 'all',\n    loading: false\n  });\n  const [newTodo, setNewTodo] = useState<string>('');\n\n  const addTodo = useCallback(() => {\n    if (newTodo.trim()) {\n      dispatch({ type: 'ADD_TODO', payload: newTodo.trim() });\n      setNewTodo('');\n    }\n  }, [newTodo]);\n\n  const filteredTodos = useMemo(() => {\n    switch (state.filter) {\n      case 'active':\n        return state.todos.filter(todo => !todo.completed);\n      case 'completed':\n        return state.todos.filter(todo => todo.completed);\n      default:\n        return state.todos;\n    }\n  }, [state.todos, state.filter]);\n\n  return (\n    <div className=\"max-w-md mx-auto p-4\">\n      <h1 className=\"text-2xl font-bold mb-4\">Todo List</h1>\n\n      <div className=\"flex gap-2 mb-4\">\n        <input\n          type=\"text\"\n          value={newTodo}\n          onChange={(e) => setNewTodo(e.target.value)}\n          onKeyPress={(e) => e.key === 'Enter' && addTodo()}\n          placeholder=\"Add new todo...\"\n          className=\"flex-1 px-3 py-2 border rounded\"\n        />\n        <button\n          onClick={addTodo}\n          className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n        >\n          Add\n        </button>\n      </div>\n\n      <div className=\"flex gap-2 mb-4\">\n        {(['all', 'active', 'completed'] as const).map(filter => (\n          <button\n            key={filter}\n            onClick={() => dispatch({ type: 'SET_FILTER', payload: filter })}\n            className={`px-3 py-1 rounded ${\n              state.filter === filter\n                ? 'bg-blue-500 text-white'\n                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'\n            }`}\n          >\n            {filter.charAt(0).toUpperCase() + filter.slice(1)}\n          </button>\n        ))}\n      </div>\n\n      <ul className=\"space-y-2\">\n        {filteredTodos.map(todo => (\n          <li\n            key={todo.id}\n            className=\"flex items-center gap-2 p-2 border rounded\"\n          >\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}\n              className=\"rounded\"\n            />\n            <span className={todo.completed ? 'line-through text-gray-500' : ''}>\n              {todo.text}\n            </span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\nThis state management pattern will inform all React state implementation with proper TypeScript and performance optimization.\n\nAll state management must use appropriate React patterns and include proper TypeScript types.\n\n## 4. Styling with Tailwind CSS\n\n### Class Organization\n- Group related classes together\n- Use consistent spacing between class groups\n- Follow this order:\n  1. Layout (display, position, etc.)\n  2. Box model (margin, padding, etc.)\n  3. Visual (colors, backgrounds, etc.)\n  4. Typography\n  5. Transitions/Animations\n\nThis class organization will inform all Tailwind CSS implementation.\n\nAll Tailwind classes must follow this organization pattern.\n\n### Component Styling Patterns\n```tsx\n// Reusable style components\nconst buttonVariants = {\n  primary: \"bg-blue-500 text-white hover:bg-blue-600 focus:ring-blue-500\",\n  secondary: \"bg-gray-500 text-white hover:bg-gray-600 focus:ring-gray-500\",\n  danger: \"bg-red-500 text-white hover:bg-red-600 focus:ring-red-500\",\n  outline: \"border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-gray-500\"\n};\n\nconst buttonSizes = {\n  sm: \"px-3 py-1.5 text-sm\",\n  md: \"px-4 py-2 text-base\",\n  lg: \"px-6 py-3 text-lg\"\n};\n\ninterface ButtonProps {\n  children: React.ReactNode;\n  variant?: keyof typeof buttonVariants;\n  size?: keyof typeof buttonSizes;\n  disabled?: boolean;\n  loading?: boolean;\n  onClick?: () => void;\n  className?: string;\n}\n\nexport function Button({\n  children,\n  variant = 'primary',\n  size = 'md',\n  disabled = false,\n  loading = false,\n  onClick,\n  className = ''\n}: ButtonProps) {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled || loading}\n      className={`\n        // Layout\n        inline-flex items-center justify-center\n\n        // Box model\n        ${buttonSizes[size]}\n\n        // Visual\n        ${buttonVariants[variant]}\n        rounded-md font-medium\n\n        // Typography\n        font-medium\n\n        // Transitions\n        transition-colors duration-200\n\n        // States\n        focus:outline-none focus:ring-2 focus:ring-offset-2\n        disabled:opacity-50 disabled:cursor-not-allowed\n\n        // Custom classes\n        ${className}\n      `}\n    >\n      {loading && (\n        <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\">\n          <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\n          <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\n        </svg>\n      )}\n      {children}\n    </button>\n  );\n}\n```\n\nThis styling pattern will inform all component styling implementation with reusable variants.\n\nAll component styling must use consistent patterns and include proper state handling.\n\n### Responsive Design\n```tsx\n// Responsive component example\nexport function ResponsiveCard() {\n  return (\n    <div className=\"\n      // Layout - responsive grid\n      grid grid-cols-1\n      sm:grid-cols-2\n      lg:grid-cols-3\n      xl:grid-cols-4\n\n      // Box model - responsive spacing\n      gap-4\n      p-4\n      sm:p-6\n      lg:p-8\n\n      // Visual\n      bg-white shadow-lg rounded-lg\n\n      // Typography - responsive text sizes\n      text-sm\n      sm:text-base\n      lg:text-lg\n    \">\n      <div className=\"\n        // Layout\n        flex flex-col\n\n        // Box model\n        p-4\n        sm:p-6\n\n        // Visual\n        bg-gray-50 rounded-lg\n\n        // Typography\n        text-center\n      \">\n        <h3 className=\"\n          text-lg\n          sm:text-xl\n          lg:text-2xl\n          font-bold\n          text-gray-900\n          mb-2\n        \">\n          Card Title\n        </h3>\n        <p className=\"\n          text-sm\n          sm:text-base\n          text-gray-600\n        \">\n          Responsive content that adapts to different screen sizes\n        </p>\n      </div>\n    </div>\n  );\n}\n```\n\nThis responsive pattern will inform all responsive design implementation.\n\nAll responsive components must use mobile-first design principles.\n\n## 5. Form Handling\n\n### Form Components\n```tsx\nimport React, { useState } from 'react';\n\ninterface FormFieldProps {\n  label: string;\n  name: string;\n  type?: 'text' | 'email' | 'password' | 'number';\n  value: string;\n  onChange: (name: string, value: string) => void;\n  error?: string;\n  required?: boolean;\n  placeholder?: string;\n}\n\nexport function FormField({\n  label,\n  name,\n  type = 'text',\n  value,\n  onChange,\n  error,\n  required = false,\n  placeholder\n}: FormFieldProps) {\n  return (\n    <div className=\"mb-4\">\n      <label htmlFor={name} className=\"\n        block\n        text-sm\n        font-medium\n        text-gray-700\n        mb-1\n      \">\n        {label}\n        {required && <span className=\"text-red-500 ml-1\">*</span>}\n      </label>\n      <input\n        id={name}\n        type={type}\n        value={value}\n        onChange={(e) => onChange(name, e.target.value)}\n        placeholder={placeholder}\n        className={`\n          // Layout\n          block w-full\n\n          // Box model\n          px-3 py-2\n\n          // Visual\n          border rounded-md\n          ${error ? 'border-red-500' : 'border-gray-300'}\n          focus:outline-none focus:ring-2\n          ${error ? 'focus:ring-red-500' : 'focus:ring-blue-500'}\n          focus:border-transparent\n\n          // Typography\n          text-sm\n\n          // Transitions\n          transition-colors duration-200\n        `}\n      />\n      {error && (\n        <p className=\"mt-1 text-sm text-red-600\">{error}</p>\n      )}\n    </div>\n  );\n}\n\n// Form validation\nexport function useFormValidation<T extends Record<string, any>>(\n  initialValues: T,\n  validationRules: Record<keyof T, (value: any) => string | undefined>\n) {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});\n\n  const validate = (name: keyof T, value: any): string | undefined => {\n    const rule = validationRules[name];\n    return rule ? rule(value) : undefined;\n  };\n\n  const handleChange = (name: keyof T, value: any) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    const error = validate(name, value);\n    setErrors(prev => ({ ...prev, [name]: error }));\n  };\n\n  const validateAll = (): boolean => {\n    const newErrors: Partial<Record<keyof T, string>> = {};\n    let isValid = true;\n\n    Object.keys(validationRules).forEach(key => {\n      const name = key as keyof T;\n      const error = validate(name, values[name]);\n      if (error) {\n        newErrors[name] = error;\n        isValid = false;\n      }\n    });\n\n    setErrors(newErrors);\n    return isValid;\n  };\n\n  return {\n    values,\n    errors,\n    handleChange,\n    validateAll,\n    setValues\n  };\n}\n\n// Usage example\nexport function LoginForm() {\n  const validationRules = {\n    email: (value: string) => {\n      if (!value) return 'Email is required';\n      if (!/\\S+@\\S+\\.\\S+/.test(value)) return 'Email is invalid';\n      return undefined;\n    },\n    password: (value: string) => {\n      if (!value) return 'Password is required';\n      if (value.length < 6) return 'Password must be at least 6 characters';\n      return undefined;\n    }\n  };\n\n  const { values, errors, handleChange, validateAll } = useFormValidation(\n    { email: '', password: '' },\n    validationRules\n  );\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (validateAll()) {\n      console.log('Form submitted:', values);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"max-w-md mx-auto p-6 bg-white rounded-lg shadow\">\n      <h2 className=\"text-2xl font-bold mb-6 text-center\">Login</h2>\n\n      <FormField\n        label=\"Email\"\n        name=\"email\"\n        type=\"email\"\n        value={values.email}\n        onChange={handleChange}\n        error={errors.email}\n        required\n        placeholder=\"Enter your email\"\n      />\n\n      <FormField\n        label=\"Password\"\n        name=\"password\"\n        type=\"password\"\n        value={values.password}\n        onChange={handleChange}\n        error={errors.password}\n        required\n        placeholder=\"Enter your password\"\n      />\n\n      <Button\n        type=\"submit\"\n        variant=\"primary\"\n        size=\"lg\"\n        className=\"w-full\"\n      >\n        Login\n      </Button>\n    </form>\n  );\n}\n```\n\nThis form pattern will inform all form implementation with proper validation and error handling.\n\nAll forms must include proper validation, error handling, and accessibility features.\n\n## 6. Error Handling and Loading States\n\n### Error Boundary\n```tsx\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div className=\"\n          // Layout\n          flex flex-col items-center justify-center\n\n          // Box model\n          p-8\n\n          // Visual\n          bg-red-50 border border-red-200 rounded-lg\n\n          // Typography\n          text-center\n        \">\n          <h2 className=\"text-xl font-semibold text-red-800 mb-2\">\n            Something went wrong\n          </h2>\n          <p className=\"text-red-600 mb-4\">\n            {this.state.error?.message || 'An unexpected error occurred'}\n          </p>\n          <button\n            onClick={() => this.setState({ hasError: false })}\n            className=\"px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n          >\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\nThis error boundary pattern will inform all error handling implementation.\n\nAll applications must include proper error boundaries and error handling.\n\n### Loading States\n```tsx\n// Loading component\nexport function LoadingSpinner({ size = 'md' }: { size?: 'sm' | 'md' | 'lg' }) {\n  const sizeClasses = {\n    sm: 'h-4 w-4',\n    md: 'h-8 w-8',\n    lg: 'h-12 w-12'\n  };\n\n  return (\n    <div className=\"flex justify-center items-center\">\n      <svg\n        className={`animate-spin ${sizeClasses[size]} text-blue-500`}\n        fill=\"none\"\n        viewBox=\"0 0 24 24\"\n      >\n        <circle\n          className=\"opacity-25\"\n          cx=\"12\"\n          cy=\"12\"\n          r=\"10\"\n          stroke=\"currentColor\"\n          strokeWidth=\"4\"\n        />\n        <path\n          className=\"opacity-75\"\n          fill=\"currentColor\"\n          d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n        />\n      </svg>\n    </div>\n  );\n}\n\n// Loading wrapper component\nexport function LoadingWrapper({\n  loading,\n  error,\n  children,\n  fallback\n}: {\n  loading: boolean;\n  error?: string | null;\n  children: ReactNode;\n  fallback?: ReactNode;\n}) {\n  if (loading) {\n    return fallback || (\n      <div className=\"flex justify-center items-center p-8\">\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"\n        // Layout\n        flex flex-col items-center justify-center\n\n        // Box model\n        p-8\n\n        // Visual\n        bg-red-50 border border-red-200 rounded-lg\n\n        // Typography\n        text-center\n      \">\n        <h3 className=\"text-lg font-semibold text-red-800 mb-2\">\n          Error Loading Content\n        </h3>\n        <p className=\"text-red-600\">{error}</p>\n      </div>\n    );\n  }\n\n  return <>{children}</>;\n}\n```\n\nThis loading pattern will inform all loading state implementation.\n\nAll components must include proper loading states and error handling.\n\n## Implementation Guidelines\n\n### For AI Assistants\n1. **Follow these patterns** for all React component implementation\n2. **Use TypeScript** with proper type definitions\n3. **Implement proper error handling** with error boundaries\n4. **Include loading states** for all async operations\n5. **Use Tailwind CSS** with proper organization\n6. **Follow responsive design** principles\n7. **Implement proper form validation** and error handling\n8. **Use appropriate state management** patterns\n\n### For Human Developers\n1. **Reference these patterns** when building React components\n2. **Use TypeScript** for type safety and better development experience\n3. **Implement error boundaries** for robust error handling\n4. **Include loading states** for better user experience\n5. **Follow Tailwind CSS** organization patterns\n6. **Test components** thoroughly with different scenarios\n7. **Optimize performance** with proper React patterns\n\n## Quality Assurance\n\n### Component Standards\n- All components must use TypeScript with proper interfaces\n- Components must follow single responsibility principle\n- Error handling must be comprehensive with error boundaries\n- Loading states must be implemented for async operations\n- Accessibility features must be included\n\n### Performance Standards\n- Components must use proper React optimization techniques\n- Bundle size must be optimized with code splitting\n- Images and assets must be optimized\n- Lazy loading must be implemented where appropriate\n- Performance must be monitored and measured\n\n### Accessibility Standards\n- Semantic HTML elements must be used\n- ARIA attributes must be properly implemented\n- Keyboard navigation must be supported\n- Color contrast must meet WCAG guidelines\n- Screen reader compatibility must be tested\n\n### Testing Standards\n- Unit tests must be written for all components\n- Integration tests must cover component interactions\n- Accessibility tests must be included\n- Performance tests must be implemented\n- Visual regression tests must be maintained\n\n---\n\n**AI Quality Checklist**: Before implementing React components, ensure:\n- [x] TypeScript interfaces are properly defined\n- [x] Components follow single responsibility principle\n- [x] Error boundaries are implemented\n- [x] Loading states are included for async operations\n- [x] Tailwind CSS classes are properly organized\n- [x] Responsive design principles are followed\n- [x] Form validation and error handling are implemented\n- [x] Accessibility features are included\n- [x] Performance optimization techniques are applied\n"
  },
  "cross_references": [],
  "code_generation_hints": [
    {
      "context": "general",
      "hint": "This organization will inform all component file placement and naming conventions.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This naming convention will inform all component naming decisions.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This component pattern will inform all React component implementation with proper TypeScript and styling.",
      "validation": ""
    },
    {
      "context": "import organization",
      "hint": "This import pattern will inform all component import organization.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This type pattern will inform all TypeScript type definition implementation.",
      "validation": ""
    },
    {
      "context": "error handling",
      "hint": "This hook pattern will inform all custom hook implementation with proper TypeScript and error handling.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This state management pattern will inform all React state implementation with proper TypeScript and performance optimization.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This class organization will inform all Tailwind CSS implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This styling pattern will inform all component styling implementation with reusable variants.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This responsive pattern will inform all responsive design implementation.",
      "validation": ""
    },
    {
      "context": "error handling",
      "hint": "This form pattern will inform all form implementation with proper validation and error handling.",
      "validation": ""
    },
    {
      "context": "error handling",
      "hint": "This error boundary pattern will inform all error handling implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This loading pattern will inform all loading state implementation.",
      "validation": ""
    }
  ],
  "validation_rules": [
    "All components must use TypeScript with proper type definitions",
    "All components must include proper error handling and loading states",
    "All state management must use appropriate React patterns and include proper TypeScript types",
    "All imports must follow this organization pattern",
    "All responsive components must use mobile-first design principles",
    "`// @ts-expect-error - React is needed for JSX` should always be above it.",
    "All components must use TypeScript with proper interfaces",
    "Loading states must be implemented for async operations",
    "Lazy loading must be implemented where appropriate",
    "All components must include proper TypeScript interfaces and type definitions",
    "All components must include proper loading states and error handling",
    "Bundle size must be optimized with code splitting",
    "Components must use proper React optimization techniques",
    "Color contrast must meet WCAG guidelines",
    "ARIA attributes must be properly implemented",
    "All components must follow this file organization structure",
    "All custom hooks must include proper TypeScript types and error handling",
    "Performance tests must be implemented",
    "4\">\n      <label htmlFor={name} className=\"\n        block\n        text-sm\n        font-medium\n        text-gray-700\n        mb-1\n      \">\n        {label}\n        {required && <span className=\"text-red-500 ml-1\">*</span>}\n      </label>\n      <input\n        id={name}\n        type={type}\n        value={value}\n        onChange={(e) => onChange(name, e.target.value)}\n        placeholder={placeholder}\n        className={`\n          // Layout\n          block w-full",
    "All component names must follow PascalCase and be descriptive",
    "Styling must use Tailwind CSS with proper organization",
    "State management must use appropriate React patterns",
    "Accessibility tests must be included",
    "Visual regression tests must be maintained",
    "Integration tests must cover component interactions",
    "All component styling must use consistent patterns and include proper state handling",
    "Semantic HTML elements must be used",
    "Unit tests must be written for all components",
    "Keyboard navigation must be supported",
    "Error handling must be comprehensive with error boundaries",
    "The first import should always be `import * as React from \"react\";`, if needed.",
    "Screen reader compatibility must be tested",
    "All Tailwind classes must follow this organization pattern",
    "All components must include proper TypeScript interfaces, error handling, and Tailwind CSS organization",
    "All forms must include proper validation, error handling, and accessibility features",
    "Performance must be monitored and measured",
    "All applications must include proper error boundaries and error handling",
    "Components must follow single responsibility principle",
    "Accessibility features must be included",
    "Images and assets must be optimized",
    "@import must precede all other statements (besides @charset or empty @layer)"
  ],
  "optimization": {
    "version": "1.0",
    "optimized_at": "2025-06-18T19:19:47.749094",
    "improvements": [
      "fixed_file_references",
      "extracted_ai_metadata",
      "structured_cross_references",
      "extracted_code_hints",
      "structured_validation_rules"
    ],
    "literal_strings_cleaned": true,
    "cleaned_at": "2025-06-18T19:30:00.000000"
  }
}