{
  "ai_metadata": {
    "purpose": "",
    "last_updated": "",
    "template_version": "2.1",
    "ai_tool_compatibility": "",
    "ai_processing_level": "High",
    "required_context": "SQLAlchemy, Alembic, PostgreSQL, database design, migrations",
    "validation_required": "Yes",
    "code_generation": "Supported",
    "cross_references": [
      "../Core%20Principles.json",
      "../Language-Specific/Python%20Style%20Guide.json",
      "../Language-Specific/Python%20Testing%20Guide.json",
      "../../project_context/Architecture%20Overview.json",
      "../../project_context/Common%20Patterns.json"
    ],
    "maintenance": ""
  },
  "file_info": {
    "file_path": "guide_docs/Domain-Specific/Database Management Guide.md",
    "original_format": "markdown",
    "converted_at": "2025-06-18T19:14:30.259760",
    "file_size": 23580,
    "line_count": 686,
    "optimized_at": "2025-06-18T19:19:47.756156",
    "optimization_version": "1.0"
  },
  "content": {
    "sections": [
      {
        "level": 1,
        "title": "Database Management Guide",
        "content": "> This guide provides comprehensive patterns and best practices for database management and operations. Use these patterns to ensure efficient, reliable database interactions.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "AI Metadata",
        "content": "**Template Version:** 2.1\n**AI Processing Level:** High\n**Required Context:** SQLAlchemy, Alembic, PostgreSQL, database design, migrations\n**Validation Required:** Yes\n**Code Generation:** Supported\n\n**Dependencies:**\n- `../Core%20Principles.json.replace(\".json\", \".json\")` - Decision-making frameworks\n- `../Language-Specific/Python%20Style%20Guide.json.replace(\".json\", \".json\")` - Python implementation patterns\n- `../Language-Specific/Python%20Testing%20Guide.json.replace(\".json\", \".json\")` - Database testing patterns\n- `../../project_context/Architecture%20Overview.json.replace(\".json\", \".json\")` - System architecture\n- `../../project_context/Common%20Patterns.json.replace(\".json\", \".json\")` - Project-specific patterns\n\n**Validation Rules:**\n- All database operations must use proper session management\n- Migrations must be atomic and reversible\n- Model imports must be explicit in env.py\n- Database permissions must follow role-based approach\n- All models must include proper type hints and validation",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Overview",
        "content": "**Document Purpose:** Database management standards and best practices for the CreamPie project\n**Scope:** SQLAlchemy models, Alembic migrations, database permissions, and testing\n**Target Users:** AI assistants and developers working with database operations\n**Last Updated:** Current\n\n**AI Context:** This guide provides the foundational database patterns that must be followed for all database operations in the project. It ensures data integrity, proper migration management, and secure database access.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "1. SQLAlchemy Guidelines",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "General Guidelines",
        "content": "- Use SQLAlchemy for database operations\n- Follow the declarative base pattern for models\n- Use type hints for model attributes\n- Keep database configuration in a separate module\n- Use environment variables for sensitive database credentials\n- Avoid the import `from sqlalchemy.orm.decl_api import mapped_column`\n\nThese guidelines will inform all SQLAlchemy model and operation implementation.\n\nAll database models must follow these guidelines and include proper type hints.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Model Definition Patterns",
        "content": "```python\nfrom sqlalchemy import Column, Integer, String, DateTime, Float, Boolean, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom typing import Optional\nfrom datetime import datetime\n\nBase = declarative_base()\n\nclass AppUser(Base):\n    \"\"\"User model for authentication and session management.\"\"\"\n    __tablename__ = \"app_users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    username = Column(String(100), unique=True, index=True, nullable=False)\n    hashed_password = Column(String(255), nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_admin = Column(Boolean, default=False, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    # Relationships\n    sessions = relationship(\"AppUserSession\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self) -> str:\n        return f\"<AppUser(id={self.id}, email='{self.email}', username='{self.username}')>\"\n\nclass AppUserSession(Base):\n    \"\"\"User session model for authentication tracking.\"\"\"\n    __tablename__ = \"app_user_sessions\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"app_users.id\"), nullable=False)\n    session_token = Column(String(255), unique=True, index=True, nullable=False)\n    expires_at = Column(DateTime(timezone=True), nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n\n    # Relationships\n    user = relationship(\"AppUser\", back_populates=\"sessions\")\n\n    def __repr__(self) -> str:\n        return f\"<AppUserSession(id={self.id}, user_id={self.user_id}, expires_at='{self.expires_at}')>\"\n\nclass TrackedStock(Base):\n    \"\"\"Model for tracking stock symbols.\"\"\"\n    __tablename__ = \"tracked_stock\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    symbol = Column(String(10), unique=True, index=True, nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    last_pull_date = Column(DateTime(timezone=True), nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    # Relationships\n    stock_data = relationship(\"StockData\", back_populates=\"tracked_stock\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self) -> str:\n        return f\"<TrackedStock(id={self.id}, symbol='{self.symbol}', is_active={self.is_active})>\"\n\nclass StockData(Base):\n    \"\"\"Model for storing stock price data.\"\"\"\n    __tablename__ = \"stock_data\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    tracked_stock_id = Column(Integer, ForeignKey(\"tracked_stock.id\"), nullable=False)\n    date = Column(DateTime(timezone=True), nullable=False)\n    open_price = Column(Float, nullable=True)\n    high_price = Column(Float, nullable=True)\n    low_price = Column(Float, nullable=True)\n    close_price = Column(Float, nullable=False)\n    volume = Column(Integer, nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n\n    # Relationships\n    tracked_stock = relationship(\"TrackedStock\", back_populates=\"stock_data\")\n\n    def __repr__(self) -> str:\n        return f\"<StockData(id={self.id}, symbol_id={self.tracked_stock_id}, date='{self.date}', close_price={self.close_price})>\"\n```\n\nThis model pattern will inform all SQLAlchemy model implementation with proper relationships and validation.\n\nAll models must include proper type hints, relationships, and validation constraints.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Database Configuration Patterns",
        "content": "```python\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import AsyncGenerator\nimport os",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Database configuration",
        "content": "DATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite+aiosqlite:///./cream_api.db\")\nASYNC_DATABASE_URL = DATABASE_URL.replace(\"sqlite://\", \"sqlite+aiosqlite://\").replace(\"postgresql://\", \"postgresql+asyncpg://\")",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Sync engine for migrations",
        "content": "engine = create_engine(\n    DATABASE_URL,\n    echo=os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\",\n    pool_pre_ping=True,\n    pool_recycle=300\n)",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Async engine for application",
        "content": "async_engine = create_async_engine(\n    ASYNC_DATABASE_URL,\n    echo=os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\",\n    pool_pre_ping=True,\n    pool_recycle=300\n)",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Session factories",
        "content": "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nAsyncSessionLocal = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\nasync def get_async_db() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Get async database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n\ndef get_sync_db():\n    \"\"\"Get sync database session.\"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n```\n\nThis configuration pattern will inform all database connection and session management implementation.\n\nAll database configuration must include proper connection pooling and session management.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "2. Database Operations",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "CRUD Operation Patterns",
        "content": "```python\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, update, delete\nfrom sqlalchemy.orm import selectinload\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\n\nclass DatabaseOperations:\n    \"\"\"Database operation patterns for common CRUD operations.\"\"\"\n\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def create_user(self, user_data: Dict[str, Any]) -> AppUser:\n        \"\"\"Create a new user.\"\"\"\n        try:\n            user = AppUser(**user_data)\n            self.session.add(user)\n            await self.session.commit()\n            await self.session.refresh(user)\n            return user\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to create user: {e}\")\n\n    async def get_user_by_id(self, user_id: int) -> Optional[AppUser]:\n        \"\"\"Get user by ID.\"\"\"\n        stmt = select(AppUser).where(AppUser.id == user_id)\n        result = await self.session.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def get_user_by_email(self, email: str) -> Optional[AppUser]:\n        \"\"\"Get user by email.\"\"\"\n        stmt = select(AppUser).where(AppUser.email == email)\n        result = await self.session.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def update_user(self, user_id: int, update_data: Dict[str, Any]) -> Optional[AppUser]:\n        \"\"\"Update user data.\"\"\"\n        try:\n            stmt = update(AppUser).where(AppUser.id == user_id).values(**update_data)\n            result = await self.session.execute(stmt)\n            await self.session.commit()\n\n            if result.rowcount > 0:\n                return await self.get_user_by_id(user_id)\n            return None\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to update user: {e}\")\n\n    async def delete_user(self, user_id: int) -> bool:\n        \"\"\"Delete user by ID.\"\"\"\n        try:\n            stmt = delete(AppUser).where(AppUser.id == user_id)\n            result = await self.session.execute(stmt)\n            await self.session.commit()\n            return result.rowcount > 0\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to delete user: {e}\")\n\n    async def get_users_with_sessions(self, limit: int = 10) -> List[AppUser]:\n        \"\"\"Get users with their sessions loaded.\"\"\"\n        stmt = (\n            select(AppUser)\n            .options(selectinload(AppUser.sessions))\n            .limit(limit)\n        )\n        result = await self.session.execute(stmt)\n        return result.scalars().all()\n\n    async def get_stock_data_by_symbol(self, symbol: str, limit: int = 100) -> List[StockData]:\n        \"\"\"Get stock data for a specific symbol.\"\"\"\n        stmt = (\n            select(StockData)\n            .join(TrackedStock)\n            .where(TrackedStock.symbol == symbol)\n            .order_by(StockData.date.desc())\n            .limit(limit)\n        )\n        result = await self.session.execute(stmt)\n        return result.scalars().all()\n```\n\nThis CRUD pattern will inform all database operation implementation with proper error handling.\n\nAll database operations must include proper error handling and transaction management.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Transaction Management Patterns",
        "content": "```python\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator, Any\n\n@asynccontextmanager\nasync def database_transaction(session: AsyncSession) -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Context manager for database transactions.\"\"\"\n    try:\n        yield session\n        await session.commit()\n    except Exception as e:\n        await session.rollback()\n        raise e\n\nasync def execute_in_transaction(session: AsyncSession, operation: callable, *args, **kwargs) -> Any:\n    \"\"\"Execute operation within a transaction.\"\"\"\n    async with database_transaction(session):\n        return await operation(*args, **kwargs)",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Usage example",
        "content": "async def create_user_with_session(session: AsyncSession, user_data: Dict[str, Any], session_data: Dict[str, Any]) -> AppUser:\n    \"\"\"Create user and session in a single transaction.\"\"\"\n    async def _create_user_and_session():\n        # Create user\n        user = AppUser(**user_data)\n        session.add(user)\n        await session.flush()  # Get user ID\n\n        # Create session\n        user_session = AppUserSession(user_id=user.id, **session_data)\n        session.add(user_session)\n\n        return user\n\n    return await execute_in_transaction(session, _create_user_and_session)\n```\n\nThis transaction pattern will inform all complex database operation implementation.\n\nAll complex operations must use proper transaction management.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "3. Database Permissions",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Role-Based Approach",
        "content": "1. Create a role with necessary permissions:\n   ```sql\n   CREATE ROLE creamapp_role;\n   GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO creamapp_role;\n   GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO creamapp_role;\n   ```\n\n2. Grant the role to the application user:\n   ```sql\n   GRANT creamapp_role TO creamapp;\n   ```\n\n3. Set default privileges for future tables:\n   ```sql\n   ALTER DEFAULT PRIVILEGES IN SCHEMA public\n   GRANT ALL PRIVILEGES ON TABLES TO creamapp_role;\n\n   ALTER DEFAULT PRIVILEGES IN SCHEMA public\n   GRANT ALL PRIVILEGES ON SEQUENCES TO creamapp_role;\n   ```\n\nThis permission pattern will inform all database security implementation.\n\nAll database permissions must follow role-based approach for security.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Permission Management Scripts",
        "content": "```bash\n#!/bin/bash",
        "subsections": []
      },
      {
        "level": 1,
        "title": "grant_table_permissions.sh",
        "content": "set -e\n\nDB_NAME=\"${DB_NAME:-cream_api}\"\nDB_USER=\"${DB_USER:-creamapp}\"\nROLE_NAME=\"${ROLE_NAME:-creamapp_role}\"\n\necho \"ðŸ” Setting up database permissions...\"",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Create role if it doesn't exist",
        "content": "psql -d \"$DB_NAME\" -c \"\nDO \\$\\$\nBEGIN\n    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '$ROLE_NAME') THEN\n        CREATE ROLE $ROLE_NAME;\n    END IF;\nEND\n\\$\\$;\n\"",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Grant permissions on existing tables",
        "content": "psql -d \"$DB_NAME\" -c \"\nGRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO $ROLE_NAME;\nGRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO $ROLE_NAME;\n\"",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Set default privileges for future tables",
        "content": "psql -d \"$DB_NAME\" -c \"\nALTER DEFAULT PRIVILEGES IN SCHEMA public\nGRANT ALL PRIVILEGES ON TABLES TO $ROLE_NAME;\n\nALTER DEFAULT PRIVILEGES IN SCHEMA public\nGRANT ALL PRIVILEGES ON SEQUENCES TO $ROLE_NAME;\n\"",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Grant role to application user",
        "content": "psql -d \"$DB_NAME\" -c \"\nGRANT $ROLE_NAME TO $DB_USER;\n\"\n\necho \"âœ… Database permissions configured successfully\"\n```\n\nThis script pattern will inform all database permission management implementation.\n\nAll permission scripts must include proper error handling and validation.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "4. Alembic Migrations",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Setup and Configuration",
        "content": "- The project uses Alembic for database migrations\n- Configuration is located in `cream_api/migrations/`\n- All SQLAlchemy models must be imported in `env.py` for autogenerate feature\n- Use `__all__` to explicitly declare model exports for static analysis tools\n\nThis migration setup will inform all database migration implementation.\n\nAll migrations must include proper model imports and configuration.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Migration Configuration",
        "content": "```python",
        "subsections": []
      },
      {
        "level": 1,
        "title": "cream_api/migrations/env.py",
        "content": "from logging.config import fileConfig\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\nfrom alembic import context\nfrom pathlib import Path\nimport sys",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Add project root to path",
        "content": "project_root = Path(__file__).parent.parent\nsys.path.append(str(project_root))",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Import all models",
        "content": "from cream_api.stock_data.models import StockData, TrackedStock\nfrom cream_api.users.models.app_user import AppUser\nfrom cream_api.users.models.app_user_session import AppUserSession",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Explicit model exports for static analysis",
        "content": "__all__ = [\n    \"AppUser\",\n    \"AppUserSession\",\n    \"StockData\",\n    \"TrackedStock\",\n]",
        "subsections": []
      },
      {
        "level": 1,
        "title": "this is the Alembic Config object",
        "content": "config = context.config",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Interpret the config file for Python logging",
        "content": "if config.config_file_name is not None:\n    fileConfig(config.config_file_name)",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Set target metadata",
        "content": "target_metadata = Base.metadata\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n```\n\nThis migration configuration will inform all Alembic setup implementation.\n\nAll migration configurations must include proper model imports and metadata setup.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Creating and Managing Migrations",
        "content": "1. Make changes to SQLAlchemy models\n2. Run the migration script:\n   ```bash\n   ./scripts/migrate.sh\n   ```\n   This will:\n   - Check for model changes\n   - Create a new migration if needed\n   - Apply pending migrations\n\nThis migration workflow will inform all database schema change implementation.\n\nAll schema changes must go through proper migration workflow.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Migration Best Practices",
        "content": "1. **Dependencies**: Consider foreign key dependencies when writing migrations:\n   ```python\n   def upgrade() -> None:\n       # Drop tables with foreign key constraints first\n       op.drop_table('sessions')  # Has foreign key to app_users\n       op.drop_table('app_users')\n       # Then drop other tables\n       op.drop_table('stock_data')\n       op.drop_table('tracked_stock')\n   ```\n\n2. **Atomic Changes**: Keep migrations focused and atomic\n3. **Documentation**: Add comments explaining complex migrations\n4. **Testing**: Test migrations both up and down\n5. **Permissions**: Ensure database user has necessary permissions\n\nThis migration pattern will inform all complex migration implementation.\n\nAll migrations must consider dependencies and include proper documentation.",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Migration Scripts",
        "content": "```bash\n#!/bin/bash",
        "subsections": []
      },
      {
        "level": 1,
        "title": "migrate.sh",
        "content": "set -e\n\nSCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\nPROJECT_ROOT=\"$( cd \"$SCRIPT_DIR/..\" && pwd )\"\n\nsource \"$SCRIPT_DIR/common.sh\"\n\nprint_status \"ðŸ”„ Running database migrations...\"\n\npushd \"$PROJECT_ROOT/cream_api\" > /dev/null",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Check for model changes and create migration if needed",
        "content": "if alembic check; then\n    print_status \"ðŸ“ Creating new migration...\"\n    alembic revision --autogenerate -m \"Auto-generated migration\"\nfi",
        "subsections": []
      },
      {
        "level": 1,
        "title": "Apply pending migrations",
        "content": "print_status \"ðŸš€ Applying migrations...\"\nalembic upgrade head\n\npopd > /dev/null\n\nprint_success \"âœ… Database migrations completed successfully\"\n```\n\nThis migration script will inform all migration automation implementation.\n\nAll migration scripts must include proper error handling and status reporting.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "5. Database Testing",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Test Database Setup",
        "content": "```python\nimport pytest\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import AsyncGenerator\n\n@pytest.fixture\nasync def test_db_engine():\n    \"\"\"Create test database engine.\"\"\"\n    engine = create_async_engine(\n        \"sqlite+aiosqlite:///:memory:\",\n        echo=False,\n        pool_pre_ping=True\n    )\n\n    # Create tables\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    yield engine\n\n    await engine.dispose()\n\n@pytest.fixture\nasync def test_db_session(test_db_engine) -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Create test database session.\"\"\"\n    TestingSessionLocal = sessionmaker(\n        test_db_engine,\n        class_=AsyncSession,\n        expire_on_commit=False\n    )\n\n    async with TestingSessionLocal() as session:\n        yield session\n\n@pytest.fixture\nasync def sample_user(test_db_session: AsyncSession) -> AppUser:\n    \"\"\"Create sample user for testing.\"\"\"\n    user = AppUser(\n        email=\"test@example.com\",\n        username=\"testuser\",\n        hashed_password=\"hashed_password\"\n    )\n    test_db_session.add(user)\n    await test_db_session.commit()\n    await test_db_session.refresh(user)\n    return user\n```\n\nThis test setup pattern will inform all database testing implementation.\n\nAll database tests must use proper test database setup and cleanup.",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Implementation Guidelines",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "For AI Assistants",
        "content": "1. **Follow these patterns** for all database implementation\n2. **Use proper session management** with async/await\n3. **Include comprehensive error handling** in all operations\n4. **Use transactions** for complex operations\n5. **Follow migration best practices** for schema changes\n6. **Implement proper testing** with isolated test databases\n7. **Use role-based permissions** for security\n8. **Include proper model relationships** and validation",
        "subsections": []
      },
      {
        "level": 3,
        "title": "For Human Developers",
        "content": "1. **Reference these patterns** when working with databases\n2. **Use async operations** for better performance\n3. **Follow migration workflow** for schema changes\n4. **Test database operations** thoroughly\n5. **Use proper error handling** and transactions\n6. **Follow security best practices** for permissions\n7. **Maintain model relationships** and constraints",
        "subsections": []
      },
      {
        "level": 2,
        "title": "Quality Assurance",
        "content": "",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Database Standards",
        "content": "- All models must include proper type hints and validation\n- Database operations must use proper session management\n- Migrations must be atomic and reversible\n- Test databases must be isolated from production\n- Permissions must follow role-based approach",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Performance Standards",
        "content": "- Database queries must be optimized and indexed\n- Connection pooling must be properly configured\n- Transactions must be kept as short as possible\n- Bulk operations must be used for large datasets\n- Database monitoring must be implemented",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Security Standards",
        "content": "- Database credentials must be stored securely\n- Role-based permissions must be implemented\n- SQL injection must be prevented through ORM usage\n- Database access must be logged and monitored\n- Sensitive data must be encrypted",
        "subsections": []
      },
      {
        "level": 3,
        "title": "Maintenance Standards",
        "content": "- Migrations must be tested before deployment\n- Database backups must be performed regularly\n- Performance must be monitored and optimized\n- Schema changes must be documented\n- Test data must be kept current and relevant\n\n---\n\n**AI Quality Checklist**: Before implementing database operations, ensure:\n- [x] Models include proper type hints and relationships\n- [x] Database operations use proper session management\n- [x] Error handling is comprehensive and includes rollback\n- [x] Migrations are atomic and include proper dependencies\n- [x] Test databases are isolated and properly configured\n- [x] Permissions follow role-based security approach\n- [x] Performance considerations are addressed\n- [x] Security measures are implemented",
        "subsections": []
      }
    ],
    "code_blocks": [
      {
        "language": "python",
        "code": "from sqlalchemy import Column, Integer, String, DateTime, Float, Boolean, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom typing import Optional\nfrom datetime import datetime\n\nBase = declarative_base()\n\nclass AppUser(Base):\n    \"\"\"User model for authentication and session management.\"\"\"\n    __tablename__ = \"app_users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    username = Column(String(100), unique=True, index=True, nullable=False)\n    hashed_password = Column(String(255), nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_admin = Column(Boolean, default=False, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    # Relationships\n    sessions = relationship(\"AppUserSession\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self) -> str:\n        return f\"<AppUser(id={self.id}, email='{self.email}', username='{self.username}')>\"\n\nclass AppUserSession(Base):\n    \"\"\"User session model for authentication tracking.\"\"\"\n    __tablename__ = \"app_user_sessions\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"app_users.id\"), nullable=False)\n    session_token = Column(String(255), unique=True, index=True, nullable=False)\n    expires_at = Column(DateTime(timezone=True), nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n\n    # Relationships\n    user = relationship(\"AppUser\", back_populates=\"sessions\")\n\n    def __repr__(self) -> str:\n        return f\"<AppUserSession(id={self.id}, user_id={self.user_id}, expires_at='{self.expires_at}')>\"\n\nclass TrackedStock(Base):\n    \"\"\"Model for tracking stock symbols.\"\"\"\n    __tablename__ = \"tracked_stock\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    symbol = Column(String(10), unique=True, index=True, nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    last_pull_date = Column(DateTime(timezone=True), nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    # Relationships\n    stock_data = relationship(\"StockData\", back_populates=\"tracked_stock\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self) -> str:\n        return f\"<TrackedStock(id={self.id}, symbol='{self.symbol}', is_active={self.is_active})>\"\n\nclass StockData(Base):\n    \"\"\"Model for storing stock price data.\"\"\"\n    __tablename__ = \"stock_data\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    tracked_stock_id = Column(Integer, ForeignKey(\"tracked_stock.id\"), nullable=False)\n    date = Column(DateTime(timezone=True), nullable=False)\n    open_price = Column(Float, nullable=True)\n    high_price = Column(Float, nullable=True)\n    low_price = Column(Float, nullable=True)\n    close_price = Column(Float, nullable=False)\n    volume = Column(Integer, nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n\n    # Relationships\n    tracked_stock = relationship(\"TrackedStock\", back_populates=\"stock_data\")\n\n    def __repr__(self) -> str:\n        return f\"<StockData(id={self.id}, symbol_id={self.tracked_stock_id}, date='{self.date}', close_price={self.close_price})>\""
      },
      {
        "language": "python",
        "code": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import AsyncGenerator\nimport os\n\n# Database configuration\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite+aiosqlite:///./cream_api.db\")\nASYNC_DATABASE_URL = DATABASE_URL.replace(\"sqlite://\", \"sqlite+aiosqlite://\").replace(\"postgresql://\", \"postgresql+asyncpg://\")\n\n# Sync engine for migrations\nengine = create_engine(\n    DATABASE_URL,\n    echo=os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\",\n    pool_pre_ping=True,\n    pool_recycle=300\n)\n\n# Async engine for application\nasync_engine = create_async_engine(\n    ASYNC_DATABASE_URL,\n    echo=os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\",\n    pool_pre_ping=True,\n    pool_recycle=300\n)\n\n# Session factories\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nAsyncSessionLocal = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\nasync def get_async_db() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Get async database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n\ndef get_sync_db():\n    \"\"\"Get sync database session.\"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"
      },
      {
        "language": "python",
        "code": "from sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, update, delete\nfrom sqlalchemy.orm import selectinload\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\n\nclass DatabaseOperations:\n    \"\"\"Database operation patterns for common CRUD operations.\"\"\"\n\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def create_user(self, user_data: Dict[str, Any]) -> AppUser:\n        \"\"\"Create a new user.\"\"\"\n        try:\n            user = AppUser(**user_data)\n            self.session.add(user)\n            await self.session.commit()\n            await self.session.refresh(user)\n            return user\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to create user: {e}\")\n\n    async def get_user_by_id(self, user_id: int) -> Optional[AppUser]:\n        \"\"\"Get user by ID.\"\"\"\n        stmt = select(AppUser).where(AppUser.id == user_id)\n        result = await self.session.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def get_user_by_email(self, email: str) -> Optional[AppUser]:\n        \"\"\"Get user by email.\"\"\"\n        stmt = select(AppUser).where(AppUser.email == email)\n        result = await self.session.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def update_user(self, user_id: int, update_data: Dict[str, Any]) -> Optional[AppUser]:\n        \"\"\"Update user data.\"\"\"\n        try:\n            stmt = update(AppUser).where(AppUser.id == user_id).values(**update_data)\n            result = await self.session.execute(stmt)\n            await self.session.commit()\n\n            if result.rowcount > 0:\n                return await self.get_user_by_id(user_id)\n            return None\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to update user: {e}\")\n\n    async def delete_user(self, user_id: int) -> bool:\n        \"\"\"Delete user by ID.\"\"\"\n        try:\n            stmt = delete(AppUser).where(AppUser.id == user_id)\n            result = await self.session.execute(stmt)\n            await self.session.commit()\n            return result.rowcount > 0\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to delete user: {e}\")\n\n    async def get_users_with_sessions(self, limit: int = 10) -> List[AppUser]:\n        \"\"\"Get users with their sessions loaded.\"\"\"\n        stmt = (\n            select(AppUser)\n            .options(selectinload(AppUser.sessions))\n            .limit(limit)\n        )\n        result = await self.session.execute(stmt)\n        return result.scalars().all()\n\n    async def get_stock_data_by_symbol(self, symbol: str, limit: int = 100) -> List[StockData]:\n        \"\"\"Get stock data for a specific symbol.\"\"\"\n        stmt = (\n            select(StockData)\n            .join(TrackedStock)\n            .where(TrackedStock.symbol == symbol)\n            .order_by(StockData.date.desc())\n            .limit(limit)\n        )\n        result = await self.session.execute(stmt)\n        return result.scalars().all()"
      },
      {
        "language": "python",
        "code": "from contextlib import asynccontextmanager\nfrom typing import AsyncGenerator, Any\n\n@asynccontextmanager\nasync def database_transaction(session: AsyncSession) -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Context manager for database transactions.\"\"\"\n    try:\n        yield session\n        await session.commit()\n    except Exception as e:\n        await session.rollback()\n        raise e\n\nasync def execute_in_transaction(session: AsyncSession, operation: callable, *args, **kwargs) -> Any:\n    \"\"\"Execute operation within a transaction.\"\"\"\n    async with database_transaction(session):\n        return await operation(*args, **kwargs)\n\n# Usage example\nasync def create_user_with_session(session: AsyncSession, user_data: Dict[str, Any], session_data: Dict[str, Any]) -> AppUser:\n    \"\"\"Create user and session in a single transaction.\"\"\"\n    async def _create_user_and_session():\n        # Create user\n        user = AppUser(**user_data)\n        session.add(user)\n        await session.flush()  # Get user ID\n\n        # Create session\n        user_session = AppUserSession(user_id=user.id, **session_data)\n        session.add(user_session)\n\n        return user\n\n    return await execute_in_transaction(session, _create_user_and_session)"
      },
      {
        "language": "sql",
        "code": "CREATE ROLE creamapp_role;\n   GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO creamapp_role;\n   GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO creamapp_role;"
      },
      {
        "language": "sql",
        "code": "GRANT creamapp_role TO creamapp;"
      },
      {
        "language": "sql",
        "code": "ALTER DEFAULT PRIVILEGES IN SCHEMA public\n   GRANT ALL PRIVILEGES ON TABLES TO creamapp_role;\n\n   ALTER DEFAULT PRIVILEGES IN SCHEMA public\n   GRANT ALL PRIVILEGES ON SEQUENCES TO creamapp_role;"
      },
      {
        "language": "bash",
        "code": "#!/bin/bash\n# grant_table_permissions.sh\n\nset -e\n\nDB_NAME=\"${DB_NAME:-cream_api}\"\nDB_USER=\"${DB_USER:-creamapp}\"\nROLE_NAME=\"${ROLE_NAME:-creamapp_role}\"\n\necho \"ðŸ” Setting up database permissions...\"\n\n# Create role if it doesn't exist\npsql -d \"$DB_NAME\" -c \"\nDO \\$\\$\nBEGIN\n    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '$ROLE_NAME') THEN\n        CREATE ROLE $ROLE_NAME;\n    END IF;\nEND\n\\$\\$;\n\"\n\n# Grant permissions on existing tables\npsql -d \"$DB_NAME\" -c \"\nGRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO $ROLE_NAME;\nGRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO $ROLE_NAME;\n\"\n\n# Set default privileges for future tables\npsql -d \"$DB_NAME\" -c \"\nALTER DEFAULT PRIVILEGES IN SCHEMA public\nGRANT ALL PRIVILEGES ON TABLES TO $ROLE_NAME;\n\nALTER DEFAULT PRIVILEGES IN SCHEMA public\nGRANT ALL PRIVILEGES ON SEQUENCES TO $ROLE_NAME;\n\"\n\n# Grant role to application user\npsql -d \"$DB_NAME\" -c \"\nGRANT $ROLE_NAME TO $DB_USER;\n\"\n\necho \"âœ… Database permissions configured successfully\""
      },
      {
        "language": "python",
        "code": "# cream_api/migrations/env.py\nfrom logging.config import fileConfig\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\nfrom alembic import context\nfrom pathlib import Path\nimport sys\n\n# Add project root to path\nproject_root = Path(__file__).parent.parent\nsys.path.append(str(project_root))\n\n# Import all models\nfrom cream_api.stock_data.models import StockData, TrackedStock\nfrom cream_api.users.models.app_user import AppUser\nfrom cream_api.users.models.app_user_session import AppUserSession\n\n# Explicit model exports for static analysis\n__all__ = [\n    \"AppUser\",\n    \"AppUserSession\",\n    \"StockData\",\n    \"TrackedStock\",\n]\n\n# this is the Alembic Config object\nconfig = context.config\n\n# Interpret the config file for Python logging\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# Set target metadata\ntarget_metadata = Base.metadata\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()"
      },
      {
        "language": "bash",
        "code": "./scripts/migrate.sh"
      },
      {
        "language": "python",
        "code": "def upgrade() -> None:\n       # Drop tables with foreign key constraints first\n       op.drop_table('sessions')  # Has foreign key to app_users\n       op.drop_table('app_users')\n       # Then drop other tables\n       op.drop_table('stock_data')\n       op.drop_table('tracked_stock')"
      },
      {
        "language": "bash",
        "code": "#!/bin/bash\n# migrate.sh\n\nset -e\n\nSCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\nPROJECT_ROOT=\"$( cd \"$SCRIPT_DIR/..\" && pwd )\"\n\nsource \"$SCRIPT_DIR/common.sh\"\n\nprint_status \"ðŸ”„ Running database migrations...\"\n\npushd \"$PROJECT_ROOT/cream_api\" > /dev/null\n\n# Check for model changes and create migration if needed\nif alembic check; then\n    print_status \"ðŸ“ Creating new migration...\"\n    alembic revision --autogenerate -m \"Auto-generated migration\"\nfi\n\n# Apply pending migrations\nprint_status \"ðŸš€ Applying migrations...\"\nalembic upgrade head\n\npopd > /dev/null\n\nprint_success \"âœ… Database migrations completed successfully\""
      },
      {
        "language": "python",
        "code": "import pytest\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import AsyncGenerator\n\n@pytest.fixture\nasync def test_db_engine():\n    \"\"\"Create test database engine.\"\"\"\n    engine = create_async_engine(\n        \"sqlite+aiosqlite:///:memory:\",\n        echo=False,\n        pool_pre_ping=True\n    )\n\n    # Create tables\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    yield engine\n\n    await engine.dispose()\n\n@pytest.fixture\nasync def test_db_session(test_db_engine) -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Create test database session.\"\"\"\n    TestingSessionLocal = sessionmaker(\n        test_db_engine,\n        class_=AsyncSession,\n        expire_on_commit=False\n    )\n\n    async with TestingSessionLocal() as session:\n        yield session\n\n@pytest.fixture\nasync def sample_user(test_db_session: AsyncSession) -> AppUser:\n    \"\"\"Create sample user for testing.\"\"\"\n    user = AppUser(\n        email=\"test@example.com\",\n        username=\"testuser\",\n        hashed_password=\"hashed_password\"\n    )\n    test_db_session.add(user)\n    await test_db_session.commit()\n    await test_db_session.refresh(user)\n    return user"
      }
    ],
    "links": [
      {
        "type": "code_reference",
        "text": "../Core%20Principles.md"
      },
      {
        "type": "code_reference",
        "text": "../Language-Specific/Python%20Style%20Guide.md"
      },
      {
        "type": "code_reference",
        "text": "../Language-Specific/Python%20Testing%20Guide.md"
      },
      {
        "type": "code_reference",
        "text": "../../project_context/Architecture%20Overview.md"
      },
      {
        "type": "code_reference",
        "text": "../../project_context/Common%20Patterns.md"
      },
      {
        "type": "code_reference",
        "text": "from sqlalchemy.orm.decl_api import mapped_column"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom sqlalchemy import Column, Integer, String, DateTime, Float, Boolean, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom typing import Optional\nfrom datetime import datetime\n\nBase = declarative_base()\n\nclass AppUser(Base):\n    \"\"\"User model for authentication and session management.\"\"\"\n    __tablename__ = \"app_users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    username = Column(String(100), unique=True, index=True, nullable=False)\n    hashed_password = Column(String(255), nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_admin = Column(Boolean, default=False, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    # Relationships\n    sessions = relationship(\"AppUserSession\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self) -> str:\n        return f\"<AppUser(id={self.id}, email='{self.email}', username='{self.username}')>\"\n\nclass AppUserSession(Base):\n    \"\"\"User session model for authentication tracking.\"\"\"\n    __tablename__ = \"app_user_sessions\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"app_users.id\"), nullable=False)\n    session_token = Column(String(255), unique=True, index=True, nullable=False)\n    expires_at = Column(DateTime(timezone=True), nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n\n    # Relationships\n    user = relationship(\"AppUser\", back_populates=\"sessions\")\n\n    def __repr__(self) -> str:\n        return f\"<AppUserSession(id={self.id}, user_id={self.user_id}, expires_at='{self.expires_at}')>\"\n\nclass TrackedStock(Base):\n    \"\"\"Model for tracking stock symbols.\"\"\"\n    __tablename__ = \"tracked_stock\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    symbol = Column(String(10), unique=True, index=True, nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    last_pull_date = Column(DateTime(timezone=True), nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    # Relationships\n    stock_data = relationship(\"StockData\", back_populates=\"tracked_stock\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self) -> str:\n        return f\"<TrackedStock(id={self.id}, symbol='{self.symbol}', is_active={self.is_active})>\"\n\nclass StockData(Base):\n    \"\"\"Model for storing stock price data.\"\"\"\n    __tablename__ = \"stock_data\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    tracked_stock_id = Column(Integer, ForeignKey(\"tracked_stock.id\"), nullable=False)\n    date = Column(DateTime(timezone=True), nullable=False)\n    open_price = Column(Float, nullable=True)\n    high_price = Column(Float, nullable=True)\n    low_price = Column(Float, nullable=True)\n    close_price = Column(Float, nullable=False)\n    volume = Column(Integer, nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n\n    # Relationships\n    tracked_stock = relationship(\"TrackedStock\", back_populates=\"stock_data\")\n\n    def __repr__(self) -> str:\n        return f\"<StockData(id={self.id}, symbol_id={self.tracked_stock_id}, date='{self.date}', close_price={self.close_price})>\"\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis model pattern will inform all SQLAlchemy model implementation with proper relationships and validation.\n\nAll models must include proper type hints, relationships, and validation constraints.\n\n### Database Configuration Patterns\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import AsyncGenerator\nimport os\n\n# Database configuration\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite+aiosqlite:///./cream_api.db\")\nASYNC_DATABASE_URL = DATABASE_URL.replace(\"sqlite://\", \"sqlite+aiosqlite://\").replace(\"postgresql://\", \"postgresql+asyncpg://\")\n\n# Sync engine for migrations\nengine = create_engine(\n    DATABASE_URL,\n    echo=os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\",\n    pool_pre_ping=True,\n    pool_recycle=300\n)\n\n# Async engine for application\nasync_engine = create_async_engine(\n    ASYNC_DATABASE_URL,\n    echo=os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\",\n    pool_pre_ping=True,\n    pool_recycle=300\n)\n\n# Session factories\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nAsyncSessionLocal = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\nasync def get_async_db() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Get async database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n\ndef get_sync_db():\n    \"\"\"Get sync database session.\"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis configuration pattern will inform all database connection and session management implementation.\n\nAll database configuration must include proper connection pooling and session management.\n\n## 2. Database Operations\n\n### CRUD Operation Patterns\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, update, delete\nfrom sqlalchemy.orm import selectinload\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\n\nclass DatabaseOperations:\n    \"\"\"Database operation patterns for common CRUD operations.\"\"\"\n\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def create_user(self, user_data: Dict[str, Any]) -> AppUser:\n        \"\"\"Create a new user.\"\"\"\n        try:\n            user = AppUser(**user_data)\n            self.session.add(user)\n            await self.session.commit()\n            await self.session.refresh(user)\n            return user\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to create user: {e}\")\n\n    async def get_user_by_id(self, user_id: int) -> Optional[AppUser]:\n        \"\"\"Get user by ID.\"\"\"\n        stmt = select(AppUser).where(AppUser.id == user_id)\n        result = await self.session.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def get_user_by_email(self, email: str) -> Optional[AppUser]:\n        \"\"\"Get user by email.\"\"\"\n        stmt = select(AppUser).where(AppUser.email == email)\n        result = await self.session.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def update_user(self, user_id: int, update_data: Dict[str, Any]) -> Optional[AppUser]:\n        \"\"\"Update user data.\"\"\"\n        try:\n            stmt = update(AppUser).where(AppUser.id == user_id).values(**update_data)\n            result = await self.session.execute(stmt)\n            await self.session.commit()\n\n            if result.rowcount > 0:\n                return await self.get_user_by_id(user_id)\n            return None\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to update user: {e}\")\n\n    async def delete_user(self, user_id: int) -> bool:\n        \"\"\"Delete user by ID.\"\"\"\n        try:\n            stmt = delete(AppUser).where(AppUser.id == user_id)\n            result = await self.session.execute(stmt)\n            await self.session.commit()\n            return result.rowcount > 0\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to delete user: {e}\")\n\n    async def get_users_with_sessions(self, limit: int = 10) -> List[AppUser]:\n        \"\"\"Get users with their sessions loaded.\"\"\"\n        stmt = (\n            select(AppUser)\n            .options(selectinload(AppUser.sessions))\n            .limit(limit)\n        )\n        result = await self.session.execute(stmt)\n        return result.scalars().all()\n\n    async def get_stock_data_by_symbol(self, symbol: str, limit: int = 100) -> List[StockData]:\n        \"\"\"Get stock data for a specific symbol.\"\"\"\n        stmt = (\n            select(StockData)\n            .join(TrackedStock)\n            .where(TrackedStock.symbol == symbol)\n            .order_by(StockData.date.desc())\n            .limit(limit)\n        )\n        result = await self.session.execute(stmt)\n        return result.scalars().all()\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis CRUD pattern will inform all database operation implementation with proper error handling.\n\nAll database operations must include proper error handling and transaction management.\n\n### Transaction Management Patterns\n"
      },
      {
        "type": "code_reference",
        "text": "python\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator, Any\n\n@asynccontextmanager\nasync def database_transaction(session: AsyncSession) -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Context manager for database transactions.\"\"\"\n    try:\n        yield session\n        await session.commit()\n    except Exception as e:\n        await session.rollback()\n        raise e\n\nasync def execute_in_transaction(session: AsyncSession, operation: callable, *args, **kwargs) -> Any:\n    \"\"\"Execute operation within a transaction.\"\"\"\n    async with database_transaction(session):\n        return await operation(*args, **kwargs)\n\n# Usage example\nasync def create_user_with_session(session: AsyncSession, user_data: Dict[str, Any], session_data: Dict[str, Any]) -> AppUser:\n    \"\"\"Create user and session in a single transaction.\"\"\"\n    async def _create_user_and_session():\n        # Create user\n        user = AppUser(**user_data)\n        session.add(user)\n        await session.flush()  # Get user ID\n\n        # Create session\n        user_session = AppUserSession(user_id=user.id, **session_data)\n        session.add(user_session)\n\n        return user\n\n    return await execute_in_transaction(session, _create_user_and_session)\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis transaction pattern will inform all complex database operation implementation.\n\nAll complex operations must use proper transaction management.\n\n## 3. Database Permissions\n\n### Role-Based Approach\n1. Create a role with necessary permissions:\n   "
      },
      {
        "type": "code_reference",
        "text": "\n\n2. Grant the role to the application user:\n   "
      },
      {
        "type": "code_reference",
        "text": "\n\n3. Set default privileges for future tables:\n   "
      },
      {
        "type": "code_reference",
        "text": "\n\nThis permission pattern will inform all database security implementation.\n\nAll database permissions must follow role-based approach for security.\n\n### Permission Management Scripts\n"
      },
      {
        "type": "code_reference",
        "text": "bash\n#!/bin/bash\n# grant_table_permissions.sh\n\nset -e\n\nDB_NAME=\"${DB_NAME:-cream_api}\"\nDB_USER=\"${DB_USER:-creamapp}\"\nROLE_NAME=\"${ROLE_NAME:-creamapp_role}\"\n\necho \"ðŸ” Setting up database permissions...\"\n\n# Create role if it doesn't exist\npsql -d \"$DB_NAME\" -c \"\nDO \\$\\$\nBEGIN\n    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '$ROLE_NAME') THEN\n        CREATE ROLE $ROLE_NAME;\n    END IF;\nEND\n\\$\\$;\n\"\n\n# Grant permissions on existing tables\npsql -d \"$DB_NAME\" -c \"\nGRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO $ROLE_NAME;\nGRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO $ROLE_NAME;\n\"\n\n# Set default privileges for future tables\npsql -d \"$DB_NAME\" -c \"\nALTER DEFAULT PRIVILEGES IN SCHEMA public\nGRANT ALL PRIVILEGES ON TABLES TO $ROLE_NAME;\n\nALTER DEFAULT PRIVILEGES IN SCHEMA public\nGRANT ALL PRIVILEGES ON SEQUENCES TO $ROLE_NAME;\n\"\n\n# Grant role to application user\npsql -d \"$DB_NAME\" -c \"\nGRANT $ROLE_NAME TO $DB_USER;\n\"\n\necho \"âœ… Database permissions configured successfully\"\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis script pattern will inform all database permission management implementation.\n\nAll permission scripts must include proper error handling and validation.\n\n## 4. Alembic Migrations\n\n### Setup and Configuration\n- The project uses Alembic for database migrations\n- Configuration is located in "
      },
      {
        "type": "code_reference",
        "text": " to explicitly declare model exports for static analysis tools\n\nThis migration setup will inform all database migration implementation.\n\nAll migrations must include proper model imports and configuration.\n\n### Migration Configuration\n"
      },
      {
        "type": "code_reference",
        "text": "python\n# cream_api/migrations/env.py\nfrom logging.config import fileConfig\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\nfrom alembic import context\nfrom pathlib import Path\nimport sys\n\n# Add project root to path\nproject_root = Path(__file__).parent.parent\nsys.path.append(str(project_root))\n\n# Import all models\nfrom cream_api.stock_data.models import StockData, TrackedStock\nfrom cream_api.users.models.app_user import AppUser\nfrom cream_api.users.models.app_user_session import AppUserSession\n\n# Explicit model exports for static analysis\n__all__ = [\n    \"AppUser\",\n    \"AppUserSession\",\n    \"StockData\",\n    \"TrackedStock\",\n]\n\n# this is the Alembic Config object\nconfig = context.config\n\n# Interpret the config file for Python logging\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# Set target metadata\ntarget_metadata = Base.metadata\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis migration configuration will inform all Alembic setup implementation.\n\nAll migration configurations must include proper model imports and metadata setup.\n\n### Creating and Managing Migrations\n1. Make changes to SQLAlchemy models\n2. Run the migration script:\n   "
      },
      {
        "type": "code_reference",
        "text": "bash\n   ./scripts/migrate.sh\n   "
      },
      {
        "type": "code_reference",
        "text": "\n   This will:\n   - Check for model changes\n   - Create a new migration if needed\n   - Apply pending migrations\n\nThis migration workflow will inform all database schema change implementation.\n\nAll schema changes must go through proper migration workflow.\n\n### Migration Best Practices\n1. **Dependencies**: Consider foreign key dependencies when writing migrations:\n   "
      },
      {
        "type": "code_reference",
        "text": "python\n   def upgrade() -> None:\n       # Drop tables with foreign key constraints first\n       op.drop_table('sessions')  # Has foreign key to app_users\n       op.drop_table('app_users')\n       # Then drop other tables\n       op.drop_table('stock_data')\n       op.drop_table('tracked_stock')\n   "
      },
      {
        "type": "code_reference",
        "text": "\n\n2. **Atomic Changes**: Keep migrations focused and atomic\n3. **Documentation**: Add comments explaining complex migrations\n4. **Testing**: Test migrations both up and down\n5. **Permissions**: Ensure database user has necessary permissions\n\nThis migration pattern will inform all complex migration implementation.\n\nAll migrations must consider dependencies and include proper documentation.\n\n### Migration Scripts\n"
      },
      {
        "type": "code_reference",
        "text": "bash\n#!/bin/bash\n# migrate.sh\n\nset -e\n\nSCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\nPROJECT_ROOT=\"$( cd \"$SCRIPT_DIR/..\" && pwd )\"\n\nsource \"$SCRIPT_DIR/common.sh\"\n\nprint_status \"ðŸ”„ Running database migrations...\"\n\npushd \"$PROJECT_ROOT/cream_api\" > /dev/null\n\n# Check for model changes and create migration if needed\nif alembic check; then\n    print_status \"ðŸ“ Creating new migration...\"\n    alembic revision --autogenerate -m \"Auto-generated migration\"\nfi\n\n# Apply pending migrations\nprint_status \"ðŸš€ Applying migrations...\"\nalembic upgrade head\n\npopd > /dev/null\n\nprint_success \"âœ… Database migrations completed successfully\"\n"
      },
      {
        "type": "code_reference",
        "text": "\n\nThis migration script will inform all migration automation implementation.\n\nAll migration scripts must include proper error handling and status reporting.\n\n## 5. Database Testing\n\n### Test Database Setup\n"
      },
      {
        "type": "code_reference",
        "text": "python\nimport pytest\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import AsyncGenerator\n\n@pytest.fixture\nasync def test_db_engine():\n    \"\"\"Create test database engine.\"\"\"\n    engine = create_async_engine(\n        \"sqlite+aiosqlite:///:memory:\",\n        echo=False,\n        pool_pre_ping=True\n    )\n\n    # Create tables\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    yield engine\n\n    await engine.dispose()\n\n@pytest.fixture\nasync def test_db_session(test_db_engine) -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Create test database session.\"\"\"\n    TestingSessionLocal = sessionmaker(\n        test_db_engine,\n        class_=AsyncSession,\n        expire_on_commit=False\n    )\n\n    async with TestingSessionLocal() as session:\n        yield session\n\n@pytest.fixture\nasync def sample_user(test_db_session: AsyncSession) -> AppUser:\n    \"\"\"Create sample user for testing.\"\"\"\n    user = AppUser(\n        email=\"test@example.com\",\n        username=\"testuser\",\n        hashed_password=\"hashed_password\"\n    )\n    test_db_session.add(user)\n    await test_db_session.commit()\n    await test_db_session.refresh(user)\n    return user\n"
      }
    ],
    "raw_content": "# Database Management Guide\n\n> This guide provides comprehensive patterns and best practices for database management and operations. Use these patterns to ensure efficient, reliable database interactions.\n\n## AI Metadata\n\n**Template Version:** 2.1\n**AI Processing Level:** High\n**Required Context:** SQLAlchemy, Alembic, PostgreSQL, database design, migrations\n**Validation Required:** Yes\n**Code Generation:** Supported\n\n**Dependencies:**\n- `../Core%20Principles.md` - Decision-making frameworks\n- `../Language-Specific/Python%20Style%20Guide.md` - Python implementation patterns\n- `../Language-Specific/Python%20Testing%20Guide.md` - Database testing patterns\n- `../../project_context/Architecture%20Overview.md` - System architecture\n- `../../project_context/Common%20Patterns.md` - Project-specific patterns\n\n**Validation Rules:**\n- All database operations must use proper session management\n- Migrations must be atomic and reversible\n- Model imports must be explicit in env.py\n- Database permissions must follow role-based approach\n- All models must include proper type hints and validation\n\n## Overview\n\n**Document Purpose:** Database management standards and best practices for the CreamPie project\n**Scope:** SQLAlchemy models, Alembic migrations, database permissions, and testing\n**Target Users:** AI assistants and developers working with database operations\n**Last Updated:** Current\n\n**AI Context:** This guide provides the foundational database patterns that must be followed for all database operations in the project. It ensures data integrity, proper migration management, and secure database access.\n\n## 1. SQLAlchemy Guidelines\n\n### General Guidelines\n- Use SQLAlchemy for database operations\n- Follow the declarative base pattern for models\n- Use type hints for model attributes\n- Keep database configuration in a separate module\n- Use environment variables for sensitive database credentials\n- Avoid the import `from sqlalchemy.orm.decl_api import mapped_column`\n\nThese guidelines will inform all SQLAlchemy model and operation implementation.\n\nAll database models must follow these guidelines and include proper type hints.\n\n### Model Definition Patterns\n```python\nfrom sqlalchemy import Column, Integer, String, DateTime, Float, Boolean, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom typing import Optional\nfrom datetime import datetime\n\nBase = declarative_base()\n\nclass AppUser(Base):\n    \"\"\"User model for authentication and session management.\"\"\"\n    __tablename__ = \"app_users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String(255), unique=True, index=True, nullable=False)\n    username = Column(String(100), unique=True, index=True, nullable=False)\n    hashed_password = Column(String(255), nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    is_admin = Column(Boolean, default=False, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    # Relationships\n    sessions = relationship(\"AppUserSession\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self) -> str:\n        return f\"<AppUser(id={self.id}, email='{self.email}', username='{self.username}')>\"\n\nclass AppUserSession(Base):\n    \"\"\"User session model for authentication tracking.\"\"\"\n    __tablename__ = \"app_user_sessions\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"app_users.id\"), nullable=False)\n    session_token = Column(String(255), unique=True, index=True, nullable=False)\n    expires_at = Column(DateTime(timezone=True), nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n\n    # Relationships\n    user = relationship(\"AppUser\", back_populates=\"sessions\")\n\n    def __repr__(self) -> str:\n        return f\"<AppUserSession(id={self.id}, user_id={self.user_id}, expires_at='{self.expires_at}')>\"\n\nclass TrackedStock(Base):\n    \"\"\"Model for tracking stock symbols.\"\"\"\n    __tablename__ = \"tracked_stock\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    symbol = Column(String(10), unique=True, index=True, nullable=False)\n    is_active = Column(Boolean, default=True, nullable=False)\n    last_pull_date = Column(DateTime(timezone=True), nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    # Relationships\n    stock_data = relationship(\"StockData\", back_populates=\"tracked_stock\", cascade=\"all, delete-orphan\")\n\n    def __repr__(self) -> str:\n        return f\"<TrackedStock(id={self.id}, symbol='{self.symbol}', is_active={self.is_active})>\"\n\nclass StockData(Base):\n    \"\"\"Model for storing stock price data.\"\"\"\n    __tablename__ = \"stock_data\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    tracked_stock_id = Column(Integer, ForeignKey(\"tracked_stock.id\"), nullable=False)\n    date = Column(DateTime(timezone=True), nullable=False)\n    open_price = Column(Float, nullable=True)\n    high_price = Column(Float, nullable=True)\n    low_price = Column(Float, nullable=True)\n    close_price = Column(Float, nullable=False)\n    volume = Column(Integer, nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n\n    # Relationships\n    tracked_stock = relationship(\"TrackedStock\", back_populates=\"stock_data\")\n\n    def __repr__(self) -> str:\n        return f\"<StockData(id={self.id}, symbol_id={self.tracked_stock_id}, date='{self.date}', close_price={self.close_price})>\"\n```\n\nThis model pattern will inform all SQLAlchemy model implementation with proper relationships and validation.\n\nAll models must include proper type hints, relationships, and validation constraints.\n\n### Database Configuration Patterns\n```python\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import AsyncGenerator\nimport os\n\n# Database configuration\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite+aiosqlite:///./cream_api.db\")\nASYNC_DATABASE_URL = DATABASE_URL.replace(\"sqlite://\", \"sqlite+aiosqlite://\").replace(\"postgresql://\", \"postgresql+asyncpg://\")\n\n# Sync engine for migrations\nengine = create_engine(\n    DATABASE_URL,\n    echo=os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\",\n    pool_pre_ping=True,\n    pool_recycle=300\n)\n\n# Async engine for application\nasync_engine = create_async_engine(\n    ASYNC_DATABASE_URL,\n    echo=os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\",\n    pool_pre_ping=True,\n    pool_recycle=300\n)\n\n# Session factories\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nAsyncSessionLocal = async_sessionmaker(\n    async_engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\nasync def get_async_db() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Get async database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n\ndef get_sync_db():\n    \"\"\"Get sync database session.\"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n```\n\nThis configuration pattern will inform all database connection and session management implementation.\n\nAll database configuration must include proper connection pooling and session management.\n\n## 2. Database Operations\n\n### CRUD Operation Patterns\n```python\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, update, delete\nfrom sqlalchemy.orm import selectinload\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\n\nclass DatabaseOperations:\n    \"\"\"Database operation patterns for common CRUD operations.\"\"\"\n\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def create_user(self, user_data: Dict[str, Any]) -> AppUser:\n        \"\"\"Create a new user.\"\"\"\n        try:\n            user = AppUser(**user_data)\n            self.session.add(user)\n            await self.session.commit()\n            await self.session.refresh(user)\n            return user\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to create user: {e}\")\n\n    async def get_user_by_id(self, user_id: int) -> Optional[AppUser]:\n        \"\"\"Get user by ID.\"\"\"\n        stmt = select(AppUser).where(AppUser.id == user_id)\n        result = await self.session.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def get_user_by_email(self, email: str) -> Optional[AppUser]:\n        \"\"\"Get user by email.\"\"\"\n        stmt = select(AppUser).where(AppUser.email == email)\n        result = await self.session.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def update_user(self, user_id: int, update_data: Dict[str, Any]) -> Optional[AppUser]:\n        \"\"\"Update user data.\"\"\"\n        try:\n            stmt = update(AppUser).where(AppUser.id == user_id).values(**update_data)\n            result = await self.session.execute(stmt)\n            await self.session.commit()\n\n            if result.rowcount > 0:\n                return await self.get_user_by_id(user_id)\n            return None\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to update user: {e}\")\n\n    async def delete_user(self, user_id: int) -> bool:\n        \"\"\"Delete user by ID.\"\"\"\n        try:\n            stmt = delete(AppUser).where(AppUser.id == user_id)\n            result = await self.session.execute(stmt)\n            await self.session.commit()\n            return result.rowcount > 0\n        except Exception as e:\n            await self.session.rollback()\n            raise ValueError(f\"Failed to delete user: {e}\")\n\n    async def get_users_with_sessions(self, limit: int = 10) -> List[AppUser]:\n        \"\"\"Get users with their sessions loaded.\"\"\"\n        stmt = (\n            select(AppUser)\n            .options(selectinload(AppUser.sessions))\n            .limit(limit)\n        )\n        result = await self.session.execute(stmt)\n        return result.scalars().all()\n\n    async def get_stock_data_by_symbol(self, symbol: str, limit: int = 100) -> List[StockData]:\n        \"\"\"Get stock data for a specific symbol.\"\"\"\n        stmt = (\n            select(StockData)\n            .join(TrackedStock)\n            .where(TrackedStock.symbol == symbol)\n            .order_by(StockData.date.desc())\n            .limit(limit)\n        )\n        result = await self.session.execute(stmt)\n        return result.scalars().all()\n```\n\nThis CRUD pattern will inform all database operation implementation with proper error handling.\n\nAll database operations must include proper error handling and transaction management.\n\n### Transaction Management Patterns\n```python\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator, Any\n\n@asynccontextmanager\nasync def database_transaction(session: AsyncSession) -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Context manager for database transactions.\"\"\"\n    try:\n        yield session\n        await session.commit()\n    except Exception as e:\n        await session.rollback()\n        raise e\n\nasync def execute_in_transaction(session: AsyncSession, operation: callable, *args, **kwargs) -> Any:\n    \"\"\"Execute operation within a transaction.\"\"\"\n    async with database_transaction(session):\n        return await operation(*args, **kwargs)\n\n# Usage example\nasync def create_user_with_session(session: AsyncSession, user_data: Dict[str, Any], session_data: Dict[str, Any]) -> AppUser:\n    \"\"\"Create user and session in a single transaction.\"\"\"\n    async def _create_user_and_session():\n        # Create user\n        user = AppUser(**user_data)\n        session.add(user)\n        await session.flush()  # Get user ID\n\n        # Create session\n        user_session = AppUserSession(user_id=user.id, **session_data)\n        session.add(user_session)\n\n        return user\n\n    return await execute_in_transaction(session, _create_user_and_session)\n```\n\nThis transaction pattern will inform all complex database operation implementation.\n\nAll complex operations must use proper transaction management.\n\n## 3. Database Permissions\n\n### Role-Based Approach\n1. Create a role with necessary permissions:\n   ```sql\n   CREATE ROLE creamapp_role;\n   GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO creamapp_role;\n   GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO creamapp_role;\n   ```\n\n2. Grant the role to the application user:\n   ```sql\n   GRANT creamapp_role TO creamapp;\n   ```\n\n3. Set default privileges for future tables:\n   ```sql\n   ALTER DEFAULT PRIVILEGES IN SCHEMA public\n   GRANT ALL PRIVILEGES ON TABLES TO creamapp_role;\n\n   ALTER DEFAULT PRIVILEGES IN SCHEMA public\n   GRANT ALL PRIVILEGES ON SEQUENCES TO creamapp_role;\n   ```\n\nThis permission pattern will inform all database security implementation.\n\nAll database permissions must follow role-based approach for security.\n\n### Permission Management Scripts\n```bash\n#!/bin/bash\n# grant_table_permissions.sh\n\nset -e\n\nDB_NAME=\"${DB_NAME:-cream_api}\"\nDB_USER=\"${DB_USER:-creamapp}\"\nROLE_NAME=\"${ROLE_NAME:-creamapp_role}\"\n\necho \"ðŸ” Setting up database permissions...\"\n\n# Create role if it doesn't exist\npsql -d \"$DB_NAME\" -c \"\nDO \\$\\$\nBEGIN\n    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '$ROLE_NAME') THEN\n        CREATE ROLE $ROLE_NAME;\n    END IF;\nEND\n\\$\\$;\n\"\n\n# Grant permissions on existing tables\npsql -d \"$DB_NAME\" -c \"\nGRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO $ROLE_NAME;\nGRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO $ROLE_NAME;\n\"\n\n# Set default privileges for future tables\npsql -d \"$DB_NAME\" -c \"\nALTER DEFAULT PRIVILEGES IN SCHEMA public\nGRANT ALL PRIVILEGES ON TABLES TO $ROLE_NAME;\n\nALTER DEFAULT PRIVILEGES IN SCHEMA public\nGRANT ALL PRIVILEGES ON SEQUENCES TO $ROLE_NAME;\n\"\n\n# Grant role to application user\npsql -d \"$DB_NAME\" -c \"\nGRANT $ROLE_NAME TO $DB_USER;\n\"\n\necho \"âœ… Database permissions configured successfully\"\n```\n\nThis script pattern will inform all database permission management implementation.\n\nAll permission scripts must include proper error handling and validation.\n\n## 4. Alembic Migrations\n\n### Setup and Configuration\n- The project uses Alembic for database migrations\n- Configuration is located in `cream_api/migrations/`\n- All SQLAlchemy models must be imported in `env.py` for autogenerate feature\n- Use `__all__` to explicitly declare model exports for static analysis tools\n\nThis migration setup will inform all database migration implementation.\n\nAll migrations must include proper model imports and configuration.\n\n### Migration Configuration\n```python\n# cream_api/migrations/env.py\nfrom logging.config import fileConfig\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\nfrom alembic import context\nfrom pathlib import Path\nimport sys\n\n# Add project root to path\nproject_root = Path(__file__).parent.parent\nsys.path.append(str(project_root))\n\n# Import all models\nfrom cream_api.stock_data.models import StockData, TrackedStock\nfrom cream_api.users.models.app_user import AppUser\nfrom cream_api.users.models.app_user_session import AppUserSession\n\n# Explicit model exports for static analysis\n__all__ = [\n    \"AppUser\",\n    \"AppUserSession\",\n    \"StockData\",\n    \"TrackedStock\",\n]\n\n# this is the Alembic Config object\nconfig = context.config\n\n# Interpret the config file for Python logging\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# Set target metadata\ntarget_metadata = Base.metadata\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n```\n\nThis migration configuration will inform all Alembic setup implementation.\n\nAll migration configurations must include proper model imports and metadata setup.\n\n### Creating and Managing Migrations\n1. Make changes to SQLAlchemy models\n2. Run the migration script:\n   ```bash\n   ./scripts/migrate.sh\n   ```\n   This will:\n   - Check for model changes\n   - Create a new migration if needed\n   - Apply pending migrations\n\nThis migration workflow will inform all database schema change implementation.\n\nAll schema changes must go through proper migration workflow.\n\n### Migration Best Practices\n1. **Dependencies**: Consider foreign key dependencies when writing migrations:\n   ```python\n   def upgrade() -> None:\n       # Drop tables with foreign key constraints first\n       op.drop_table('sessions')  # Has foreign key to app_users\n       op.drop_table('app_users')\n       # Then drop other tables\n       op.drop_table('stock_data')\n       op.drop_table('tracked_stock')\n   ```\n\n2. **Atomic Changes**: Keep migrations focused and atomic\n3. **Documentation**: Add comments explaining complex migrations\n4. **Testing**: Test migrations both up and down\n5. **Permissions**: Ensure database user has necessary permissions\n\nThis migration pattern will inform all complex migration implementation.\n\nAll migrations must consider dependencies and include proper documentation.\n\n### Migration Scripts\n```bash\n#!/bin/bash\n# migrate.sh\n\nset -e\n\nSCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\nPROJECT_ROOT=\"$( cd \"$SCRIPT_DIR/..\" && pwd )\"\n\nsource \"$SCRIPT_DIR/common.sh\"\n\nprint_status \"ðŸ”„ Running database migrations...\"\n\npushd \"$PROJECT_ROOT/cream_api\" > /dev/null\n\n# Check for model changes and create migration if needed\nif alembic check; then\n    print_status \"ðŸ“ Creating new migration...\"\n    alembic revision --autogenerate -m \"Auto-generated migration\"\nfi\n\n# Apply pending migrations\nprint_status \"ðŸš€ Applying migrations...\"\nalembic upgrade head\n\npopd > /dev/null\n\nprint_success \"âœ… Database migrations completed successfully\"\n```\n\nThis migration script will inform all migration automation implementation.\n\nAll migration scripts must include proper error handling and status reporting.\n\n## 5. Database Testing\n\n### Test Database Setup\n```python\nimport pytest\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom typing import AsyncGenerator\n\n@pytest.fixture\nasync def test_db_engine():\n    \"\"\"Create test database engine.\"\"\"\n    engine = create_async_engine(\n        \"sqlite+aiosqlite:///:memory:\",\n        echo=False,\n        pool_pre_ping=True\n    )\n\n    # Create tables\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    yield engine\n\n    await engine.dispose()\n\n@pytest.fixture\nasync def test_db_session(test_db_engine) -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Create test database session.\"\"\"\n    TestingSessionLocal = sessionmaker(\n        test_db_engine,\n        class_=AsyncSession,\n        expire_on_commit=False\n    )\n\n    async with TestingSessionLocal() as session:\n        yield session\n\n@pytest.fixture\nasync def sample_user(test_db_session: AsyncSession) -> AppUser:\n    \"\"\"Create sample user for testing.\"\"\"\n    user = AppUser(\n        email=\"test@example.com\",\n        username=\"testuser\",\n        hashed_password=\"hashed_password\"\n    )\n    test_db_session.add(user)\n    await test_db_session.commit()\n    await test_db_session.refresh(user)\n    return user\n```\n\nThis test setup pattern will inform all database testing implementation.\n\nAll database tests must use proper test database setup and cleanup.\n\n## Implementation Guidelines\n\n### For AI Assistants\n1. **Follow these patterns** for all database implementation\n2. **Use proper session management** with async/await\n3. **Include comprehensive error handling** in all operations\n4. **Use transactions** for complex operations\n5. **Follow migration best practices** for schema changes\n6. **Implement proper testing** with isolated test databases\n7. **Use role-based permissions** for security\n8. **Include proper model relationships** and validation\n\n### For Human Developers\n1. **Reference these patterns** when working with databases\n2. **Use async operations** for better performance\n3. **Follow migration workflow** for schema changes\n4. **Test database operations** thoroughly\n5. **Use proper error handling** and transactions\n6. **Follow security best practices** for permissions\n7. **Maintain model relationships** and constraints\n\n## Quality Assurance\n\n### Database Standards\n- All models must include proper type hints and validation\n- Database operations must use proper session management\n- Migrations must be atomic and reversible\n- Test databases must be isolated from production\n- Permissions must follow role-based approach\n\n### Performance Standards\n- Database queries must be optimized and indexed\n- Connection pooling must be properly configured\n- Transactions must be kept as short as possible\n- Bulk operations must be used for large datasets\n- Database monitoring must be implemented\n\n### Security Standards\n- Database credentials must be stored securely\n- Role-based permissions must be implemented\n- SQL injection must be prevented through ORM usage\n- Database access must be logged and monitored\n- Sensitive data must be encrypted\n\n### Maintenance Standards\n- Migrations must be tested before deployment\n- Database backups must be performed regularly\n- Performance must be monitored and optimized\n- Schema changes must be documented\n- Test data must be kept current and relevant\n\n---\n\n**AI Quality Checklist**: Before implementing database operations, ensure:\n- [x] Models include proper type hints and relationships\n- [x] Database operations use proper session management\n- [x] Error handling is comprehensive and includes rollback\n- [x] Migrations are atomic and include proper dependencies\n- [x] Test databases are isolated and properly configured\n- [x] Permissions follow role-based security approach\n- [x] Performance considerations are addressed\n- [x] Security measures are implemented\n"
  },
  "cross_references": [],
  "code_generation_hints": [
    {
      "context": "general",
      "hint": "These guidelines will inform all SQLAlchemy model and operation implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This model pattern will inform all SQLAlchemy model implementation with proper relationships and validation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This configuration pattern will inform all database connection and session management implementation.",
      "validation": ""
    },
    {
      "context": "error handling",
      "hint": "This CRUD pattern will inform all database operation implementation with proper error handling.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This transaction pattern will inform all complex database operation implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This permission pattern will inform all database security implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This script pattern will inform all database permission management implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This migration setup will inform all database migration implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This migration configuration will inform all Alembic setup implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This migration workflow will inform all database schema change implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This migration pattern will inform all complex migration implementation.",
      "validation": ""
    },
    {
      "context": "general",
      "hint": "This migration script will inform all migration automation implementation.",
      "validation": ""
    },
    {
      "context": "testing",
      "hint": "This test setup pattern will inform all database testing implementation.",
      "validation": ""
    }
  ],
  "validation_rules": [
    "All models must include proper type hints and validation",
    "Test databases must be isolated from production",
    "All permission scripts must include proper error handling and validation",
    "Database permissions must follow role-based approach",
    "All schema changes must go through proper migration workflow",
    "All SQLAlchemy models must be imported in `env.py` for autogenerate feature",
    "Database access must be logged and monitored",
    "Performance must be monitored and optimized",
    "Database credentials must be stored securely",
    "Sensitive data must be encrypted",
    "All database configuration must include proper connection pooling and session management",
    "Database queries must be optimized and indexed",
    "Role-based permissions must be implemented",
    "Migrations must be tested before deployment",
    "SQL injection must be prevented through ORM usage",
    "All database permissions must follow role-based approach for security",
    "Database monitoring must be implemented",
    "All migrations must include proper model imports and configuration",
    "All migration configurations must include proper model imports and metadata setup",
    "Bulk operations must be used for large datasets",
    "All migration scripts must include proper error handling and status reporting",
    "Database backups must be performed regularly",
    "Model imports must be explicit in env.py",
    "Connection pooling must be properly configured",
    "Database operations must use proper session management",
    "Permissions must follow role-based approach",
    "Test data must be kept current and relevant",
    "Migrations must be atomic and reversible",
    "All database operations must use proper session management",
    "Transactions must be kept as short as possible",
    "Schema changes must be documented",
    "All database tests must use proper test database setup and cleanup",
    "All complex operations must use proper transaction management",
    "All database operations must include proper error handling and transaction management",
    "All models must include proper type hints, relationships, and validation constraints",
    "All database models must follow these guidelines and include proper type hints",
    "All migrations must consider dependencies and include proper documentation"
  ],
  "optimization": {
    "version": "1.0",
    "optimized_at": "2025-06-18T19:19:47.756160",
    "improvements": [
      "fixed_file_references",
      "extracted_ai_metadata",
      "structured_cross_references",
      "extracted_code_hints",
      "structured_validation_rules"
    ],
    "literal_strings_cleaned": true,
    "cleaned_at": "2025-06-18T19:30:00.000000"
  }
}