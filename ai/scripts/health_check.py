#!/usr/bin/env python3
"""
AI Documentation Health Check Script

This script validates the AI documentation structure, metadata, and cross-references
to ensure optimal AI tool consumption. Updated for JSON format.
"""

import json
import os
import sys
import urllib.parse
from datetime import datetime


class AIDocumentationHealthCheck:
    def __init__(self):
        # Get the ai folder path (parent of scripts folder)
        self.script_dir = os.path.dirname(__file__)
        self.ai_folder = os.path.dirname(self.script_dir)

        self.issues = []
        self.warnings = []
        self.success_count = 0

    def run_health_check(self):
        """Run the complete health check and generate report."""
        print("üîç Running AI Documentation Health Check...")
        print()

        # Run all checks
        self.check_folder_structure()
        self.check_ai_metadata()
        self.check_cross_references()
        self.check_search_index()
        self.check_quick_reference()
        self.check_ai_config()
        self.check_template_consistency()

        # Generate report
        report = self.generate_report()

        # Print to console
        print(report)

        # Write to file
        result_file = os.path.join(self.ai_folder, "outputs", "health_check", "healthcheck-result.md")

        # Ensure the output directory exists
        result_dir = os.path.dirname(result_file)
        os.makedirs(result_dir, exist_ok=True)

        # Calculate relative paths for cross-references using os.path as recommended in style guide
        health_check_rel = os.path.relpath(os.path.join(self.ai_folder, "scripts", "health_check.py"), result_dir)
        update_rel = os.path.relpath(os.path.join(self.ai_folder, "scripts", "update_documentation.py"), result_dir)
        config_rel = os.path.relpath(os.path.join(self.ai_folder, "ai_config.json"), result_dir)

        # Generate the complete file content dynamically
        file_content = f"""# AI Documentation Health Check Results

> **AI Assistant**:
This file contains the results of the AI documentation health check.
It provides insights into the quality and completeness of the AI documentation system.

## AI Metadata

- **Purpose**: Health check results and status report for AI documentation optimization
- **Last Updated**: 2025-01-27
- **Template Version**: 3.0
- **AI Tool Compatibility**: High
- **AI Processing Level**: High
- **Required Context**: AI documentation structure and standards
- **Validation Required**: Yes
- **Code Generation**: Not applicable
- **Cross-References**:
  - `{health_check_rel}` - Health check script
  - `{update_rel}` - Update script
  - `{config_rel}` - AI configuration
- **Maintenance**: Auto-generated by health check script

---

{report}"""

        with open(result_file, "w", encoding="utf-8") as f:
            f.write(file_content)
            f.flush()  # Force flush to disk
            os.fsync(f.fileno())  # Force sync to ensure file is written

        # Get file stats using os.path
        stat_info = os.stat(result_file)
        print(f"\nüìÑ Health check results saved to: {result_file}")
        print(f"üìÑ File size: {stat_info.st_size} bytes")
        print(f"üìÑ File modified: {datetime.fromtimestamp(stat_info.st_mtime)}")

        return len(self.issues) == 0

    def check_folder_structure(self):
        """Check that all required folders and files exist."""
        print("üìÅ Checking folder structure...")

        # Debug: Print the paths being checked
        print(f"üîç AI folder path: {self.ai_folder}")
        print(f"üîç Current working directory: {os.getcwd()}")

        required_files = [
            "README.json",
            "ai_quick_reference.json",
            "search_index.json",
            "ai_config.json",
            "guide_docs/README.json",
            "guide_docs/Core Principles.json",
            "guide_docs/Feature Template.json",
            "guide_docs/Code Review Patterns.json",
            "guide_docs/AI Tool Optimization Guide.json",
            "project_context/README.json",
            "project_context/Architecture Overview.json",
            "project_context/Common Patterns.json",
            "project_context/Development Workflow.json",
        ]

        for file_path in required_files:
            full_path = os.path.join(self.ai_folder, file_path)
            if os.path.exists(full_path):
                self.success_count += 1
                print(f"‚úÖ Found: {file_path}")
            else:
                self.issues.append(f"Missing required file: {file_path}")
                print(f"‚ùå Missing: {file_path} (checked at: {full_path})")

        # Check language-specific guides
        lang_guides = [
            "guide_docs/Language-Specific/Python Style Guide.json",
            "guide_docs/Language-Specific/FastAPI Development Guide.json",
            "guide_docs/Language-Specific/Python Testing Guide.json",
        ]

        for guide in lang_guides:
            if os.path.exists(os.path.join(self.ai_folder, guide)):
                self.success_count += 1
            else:
                self.warnings.append(f"Missing language guide: {guide}")

        # Check domain-specific guides
        domain_guides = [
            "guide_docs/Domain-Specific/Database Management Guide.json",
            "guide_docs/Domain-Specific/Frontend Style Guide.json",
            "guide_docs/Domain-Specific/Web Scraping Patterns.json",
            "guide_docs/Domain-Specific/Shell Style Guide.json",
        ]

        for guide in domain_guides:
            if os.path.exists(os.path.join(self.ai_folder, guide)):
                self.success_count += 1
            else:
                self.warnings.append(f"Missing domain guide: {guide}")

    def check_ai_metadata(self):
        """Check that all JSON files have proper AI metadata."""
        print("üìã Checking AI metadata...")

        for root, _, files in os.walk(self.ai_folder):
            for file in files:
                if file.endswith(".json") and not file.startswith("ai_config"):
                    file_path = os.path.join(root, file)
                    # Skip output files
                    if "outputs" in file_path:
                        continue

                    self._check_single_file_metadata(file_path)

    def _check_single_file_metadata(self, file_path):
        """Check AI metadata for a single file."""
        try:
            with open(file_path, encoding="utf-8") as f:
                data = json.load(f)

            relative_path = os.path.relpath(file_path, self.ai_folder)

            # Check for AI metadata section
            if "ai_metadata" not in data:
                self.issues.append(f"Missing AI metadata section: {relative_path}")
            else:
                self.success_count += 1

            # Check for required AI metadata fields
            self._check_ai_metadata_fields(data, relative_path)

            # Check for file_info section
            if "file_info" not in data:
                self.issues.append(f"Missing file_info section: {relative_path}")
            else:
                self.success_count += 1

            # Check for content section
            if "content" not in data:
                self.issues.append(f"Missing content section: {relative_path}")
            else:
                self.success_count += 1

        except json.JSONDecodeError as e:
            self.issues.append(f"Invalid JSON in {relative_path}: {e!s}")
        except Exception as e:
            self.issues.append(f"Error reading {relative_path}: {e!s}")

    def _check_ai_metadata_fields(self, data, relative_path):
        """Check required AI metadata fields."""
        ai_metadata = data.get("ai_metadata", {})
        required_fields = ["template_version", "ai_processing_level", "required_context"]

        for field in required_fields:
            if not ai_metadata.get(field):
                self.warnings.append(f"Missing AI metadata field '{field}': {relative_path}")
            else:
                self.success_count += 1

    def check_cross_references(self):
        """Check that cross-references are valid and bidirectional."""
        print("üîó Checking cross-references...")

        # Get all JSON files
        json_files = []
        for root, _, files in os.walk(self.ai_folder):
            for file in files:
                if file.endswith(".json") and not file.startswith("ai_config"):
                    file_path = os.path.join(root, file)
                    if "outputs" not in file_path:
                        json_files.append(file_path)

        file_paths = {os.path.relpath(f, self.ai_folder): f for f in json_files}

        # Check cross-references in each file
        for file_path in json_files:
            self._check_file_cross_references(file_path, file_paths)

    def _check_file_cross_references(self, file_path, file_paths):
        """Check cross-references for a single file."""
        try:
            with open(file_path, encoding="utf-8") as f:
                data = json.load(f)

            relative_path = os.path.relpath(file_path, self.ai_folder)

            # Check structured cross-references
            self._check_structured_cross_references(data, relative_path, file_paths)

            # Check cross-references in AI metadata
            self._check_metadata_cross_references(data, relative_path, file_paths)

            self.success_count += 1

        except Exception as e:
            self.issues.append(f"Error checking cross-references in {relative_path}: {e!s}")

    def _check_structured_cross_references(self, data, relative_path, file_paths):
        """Check structured cross-references in a file."""
        cross_refs = data.get("cross_references", [])
        for ref in cross_refs:
            if isinstance(ref, dict):
                ref_path = ref.get("path", "")
            else:
                ref_path = ref

            if ref_path:
                # Skip example placeholders
                if self._is_example_placeholder(ref_path):
                    continue

                # Check if referenced file exists (try multiple variations)
                if not self._file_exists_in_paths(ref_path, file_paths):
                    self.warnings.append(f"Cross-reference to non-existent file: {ref_path} in {relative_path}")

    def _check_metadata_cross_references(self, data, relative_path, file_paths):
        """Check cross-references in AI metadata."""
        ai_metadata = data.get("ai_metadata", {})
        metadata_refs = ai_metadata.get("cross_references", [])
        for ref in metadata_refs:
            # Skip example placeholders
            if self._is_example_placeholder(ref):
                continue

            if not self._file_exists_in_paths(ref, file_paths):
                self.warnings.append(f"AI metadata cross-reference to non-existent file: {ref} in {relative_path}")

    def _file_exists_in_paths(self, ref_path, file_paths):
        """Check if a file exists in the file paths, trying multiple variations."""
        file_exists = False

        # Try the original path
        if ref_path in file_paths:
            file_exists = True

        # Try URL-decoded path
        elif self._try_decoded_path(ref_path, file_paths):
            file_exists = True

        # Try with spaces instead of %20
        elif "%20" in ref_path:
            space_path = ref_path.replace("%20", " ")
            if space_path in file_paths:
                file_exists = True

        # Try with underscores instead of %20
        elif "%20" in ref_path:
            underscore_path = ref_path.replace("%20", "_")
            if underscore_path in file_paths:
                file_exists = True

        # Try relative to current directory
        elif self._try_relative_path(ref_path, file_paths):
            file_exists = True

        # Check if it's a special file that should be ignored
        elif self._should_ignore_reference(ref_path):
            file_exists = True

        # Final check: try to find any file that matches the decoded name
        elif self._try_basename_match(ref_path, file_paths):
            file_exists = True

        return file_exists

    def _try_decoded_path(self, ref_path, file_paths):
        """Try URL-decoded path."""
        try:
            decoded_path = urllib.parse.unquote(ref_path)
            return decoded_path in file_paths
        except Exception:
            return False

    def _try_relative_path(self, ref_path, file_paths):
        """Try relative path checks."""
        current_dir = os.path.dirname(ref_path)
        if current_dir:
            # Check if it's a directory reference
            if ref_path.endswith("/") and current_dir in file_paths:
                return True

            # Check if it's a script or config file
            if ref_path.endswith((".py", ".sh", ".js", ".json")):
                return True

        return False

    def _try_basename_match(self, ref_path, file_paths):
        """Try to find any file that matches the decoded name."""
        try:
            decoded_path = urllib.parse.unquote(ref_path)
            for existing_path in file_paths:
                if os.path.basename(decoded_path) == os.path.basename(existing_path):
                    return True
        except Exception:
            pass

        return False

    def _should_ignore_reference(self, ref_path):
        """Check if a reference should be ignored (scripts, configs, etc.)."""
        # Ignore script files
        if ref_path.startswith("scripts/"):
            return True

        # Ignore config files
        if ref_path == "ai_config.json":
            return True

        # Ignore output directories
        if ref_path.startswith("outputs/"):
            return True

        # Ignore directory references
        if ref_path.endswith("/"):
            return True

        return False

    def _is_example_placeholder(self, path):
        """Check if a path is an example placeholder."""
        placeholder_patterns = ["path/to/", "example", "placeholder", "template"]

        path_lower = path.lower()
        return any(pattern in path_lower for pattern in placeholder_patterns)

    def check_search_index(self):
        """Check that search index is comprehensive and up-to-date."""
        print("üîç Checking search index...")

        search_index_path = os.path.join(self.ai_folder, "search_index.json")
        if not os.path.exists(search_index_path):
            self.issues.append("Missing search index file")
            return

        try:
            with open(search_index_path, encoding="utf-8") as f:
                data = json.load(f)

            # Check that search index has required sections
            if "content" not in data:
                self.issues.append("Search index missing content section")
            else:
                self.success_count += 1

            # Check that search index has sections
            sections = data.get("content", {}).get("sections", [])
            if not sections:
                self.warnings.append("Search index has no sections")
            else:
                self.success_count += 1

        except Exception as e:
            self.issues.append(f"Error reading search index: {e!s}")

    def check_quick_reference(self):
        """Check that quick reference is comprehensive and accessible."""
        print("üìñ Checking quick reference...")

        quick_ref_path = os.path.join(self.ai_folder, "ai_quick_reference.json")
        if not os.path.exists(quick_ref_path):
            self.issues.append("Missing quick reference file")
            return

        try:
            with open(quick_ref_path, encoding="utf-8") as f:
                data = json.load(f)

            # Check that quick reference has required sections
            if "content" not in data:
                self.issues.append("Quick reference missing content section")
            else:
                self.success_count += 1

            # Check that quick reference has sections
            sections = data.get("content", {}).get("sections", [])
            if not sections:
                self.warnings.append("Quick reference has no sections")
            else:
                self.success_count += 1

        except Exception as e:
            self.issues.append(f"Error reading quick reference: {e!s}")

    def check_ai_config(self):
        """Check that AI configuration is valid and up-to-date."""
        print("‚öôÔ∏è Checking AI configuration...")

        config_path = os.path.join(self.ai_folder, "ai_config.json")
        if not os.path.exists(config_path):
            self.issues.append("Missing AI configuration file")
            return

        try:
            with open(config_path, encoding="utf-8") as f:
                config = json.load(f)

            # Check required configuration sections
            required_sections = ["ai_documentation_config", "documentation_structure", "ai_tool_settings"]
            for section in required_sections:
                if section not in config:
                    self.issues.append(f"Missing configuration section: {section}")
                else:
                    self.success_count += 1

            # Check version
            version = config.get("ai_documentation_config", {}).get("version")
            if version != "3.0":
                self.warnings.append(f"Configuration version mismatch: expected 3.0, got {version}")

        except Exception as e:
            self.issues.append(f"Error reading AI configuration: {e!s}")

    def check_template_consistency(self):
        """Check that all files follow consistent template structure."""
        print("üìã Checking template consistency...")

        for root, _, files in os.walk(self.ai_folder):
            for file in files:
                if file.endswith(".json") and not file.startswith("ai_config"):
                    file_path = os.path.join(root, file)

                    # Skip output files and health check result
                    if "outputs" in file_path or os.path.basename(file_path) == "healthcheck-result.md":
                        continue

                    try:
                        with open(file_path, encoding="utf-8") as f:
                            data = json.load(f)

                        relative_path = os.path.relpath(file_path, self.ai_folder)

                        # Check required top-level sections
                        required_sections = ["ai_metadata", "file_info", "content"]
                        for section in required_sections:
                            if section not in data:
                                self.issues.append(f"Missing required section '{section}': {relative_path}")
                            else:
                                self.success_count += 1

                        # Check content structure
                        content = data.get("content", {})
                        if "sections" not in content:
                            self.warnings.append(f"Missing sections in content: {relative_path}")
                        else:
                            self.success_count += 1

                    except Exception as e:
                        self.issues.append(f"Error checking template consistency in {relative_path}: {e!s}")

    def generate_report(self):
        """Generate the health check report."""
        self.success_count + len(self.issues) + len(self.warnings)

        report = f"""üìä AI Documentation Health Check Report
============================================================

‚úÖ Successful checks: {self.success_count}
‚ùå Issues found: {len(self.issues)}
‚ö†Ô∏è Warnings: {len(self.warnings)}

"""

        if self.issues:
            report += "\n‚ùå Issues:\n"
            for issue in self.issues:
                report += f"  - {issue}\n"

        if self.warnings:
            report += "\n‚ö†Ô∏è Warnings:\n"
            for warning in self.warnings:
                report += f"  - {warning}\n"

        if not self.issues and not self.warnings:
            report += "\nüéâ All checks passed! AI documentation is optimized for tool consumption."
        else:
            report += "\nüîß Please address the issues and warnings above."

        report += "\n============================================================"

        return report


def main():
    """Main health check function."""
    health_check = AIDocumentationHealthCheck()
    success = health_check.run_health_check()

    if success:
        print("\n‚úÖ Health check completed successfully!")
        sys.exit(0)
    else:
        print("\n‚ùå Health check found issues that need attention.")
        sys.exit(1)


if __name__ == "__main__":
    main()
